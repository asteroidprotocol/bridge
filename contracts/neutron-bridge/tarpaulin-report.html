<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse neutron_sdk::bindings::msg::NeutronMsg;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\nuse crate::error::ContractError;\nuse crate::msg::{InstantiateMsg, MigrateMsg};\nuse crate::state::CONFIG;\nuse crate::types::{Config, MAX_IBC_TIMEOUT_SECONDS, MIN_IBC_TIMEOUT_SECONDS};\n\n/// Contract name that is used for migration\nconst CONTRACT_NAME: \u0026str = \"asteroid-bridge\";\n/// Contract version that is used for migration\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the bridge contract, storing the config.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    // The bridge IBC channel must be specified, that is, the channel used\n    // to send information back to the source chain\n    if msg.bridge_ibc_channel.is_empty() {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string(),\n        });\n    }\n\n    // The source chain ID must be specified, that is, the chain ID of the\n    // source chain, not the chain ID where this contract is deployed\n    if msg.bridge_chain_id.is_empty() {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The source chain ID must be specified\".to_string(),\n        });\n    }\n\n    // Ensure valid IBC timeouts are set\n    if !(MIN_IBC_TIMEOUT_SECONDS..=MAX_IBC_TIMEOUT_SECONDS).contains(\u0026msg.ibc_timeout_seconds) {\n        return Err(ContractError::InvalidIBCTimeout {\n            timeout: msg.ibc_timeout_seconds,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        });\n    }\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        bridge_chain_id: msg.bridge_chain_id.clone(),\n        bridge_ibc_channel: msg.bridge_ibc_channel.clone(),\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\"bridge_chain_id\", msg.bridge_chain_id)\n        .add_attribute(\"bridge_ibc_channel\", msg.bridge_ibc_channel))\n}\n\n/// Migrates the contract to a new version, storing the new contract version.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_version = cw2::get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"asteroid-bridge\" =\u003e match contract_version.version.as_ref() {\n            \"1.0.1\" =\u003e {\n                let mut config = CONFIG.load(deps.storage)?;\n\n                // Allow changing the source chain ID in case the source chain\n                // undergoes an upgrade that changes the chain ID\n                if let Some(bridge_chain_id) = msg.bridge_chain_id {\n                    if bridge_chain_id.is_empty() {\n                        return Err(ContractError::InvalidConfiguration {\n                            reason: \"The source chain ID must be specified\".to_string(),\n                        });\n                    }\n                    config.bridge_chain_id = bridge_chain_id;\n                }\n\n                CONFIG.save(deps.storage, \u0026config)?;\n            }\n            _ =\u003e return Err(ContractError::MigrationError {}),\n        },\n        _ =\u003e return Err(ContractError::MigrationError {}),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n","traces":[{"line":20,"address":[11459488,11461354,11461678],"length":1,"stats":{"Line":12},"fn_name":"instantiate"},{"line":26,"address":[11461573,11459728,11459528,11459657],"length":1,"stats":{"Line":24},"fn_name":null},{"line":30,"address":[11459708,11459822],"length":1,"stats":{"Line":24},"fn_name":null},{"line":31,"address":[2320524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2318948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2318933,2318982],"length":1,"stats":{"Line":24},"fn_name":null},{"line":39,"address":[2320424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2319015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2318993,2319049],"length":1,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[2319114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2319110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2320417,2319065,2319384,2319216],"length":1,"stats":{"Line":23},"fn_name":null},{"line":55,"address":[2319353],"length":1,"stats":{"Line":12},"fn_name":null},{"line":56,"address":[2319522],"length":1,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[2319596],"length":1,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[2319704,2319853,2319781],"length":1,"stats":{"Line":24},"fn_name":null},{"line":61,"address":[2319841,2319942,2320107,2320027],"length":1,"stats":{"Line":48},"fn_name":null},{"line":63,"address":[2319995],"length":1,"stats":{"Line":12},"fn_name":null},{"line":64,"address":[2320075],"length":1,"stats":{"Line":12},"fn_name":null},{"line":69,"address":[2323200,2322293,2320752],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":70,"address":[2320897,2321072,2320787,2323126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2321047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2321297,2321212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2321351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2321441,2321613,2323090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2322081,2321707,2321579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2321855,2321754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2322091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2321920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2321950,2321861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[2323085,2322376,2322304,2321770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2321389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2321250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2322598,2323080,2322470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2322735,2322586,2322687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2322727],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":19,"coverable":36},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError, Uint128, VerificationError};\nuse ed25519_dalek::SignatureError;\nuse thiserror::Error;\n\n/// This enum describes bribes contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"The CFT-20 token '{ticker}' is already linked\")]\n    TokenAlreadyExists { ticker: String },\n\n    #[error(\"The CFT-20 token '{ticker}' has not been linked for bridging\")]\n    TokenDoesNotExist { ticker: String },\n\n    #[error(\"Insufficient valid signatures to confirm the message\")]\n    ThresholdNotMet {},\n\n    #[error(\"Duplicated signatures are not allowed\")]\n    DuplicateSignatures {},\n\n    #[error(\"This token has been disabled from bridging: {ticker}\")]\n    TokenDisabled { ticker: String },\n\n    #[error(\"The transaction has already been handled: {transaction_hash}\")]\n    TransactionAlreadyHandled { transaction_hash: String },\n\n    #[error(\"You can not send 0 CFT-20 tokens\")]\n    ZeroAmount {},\n\n    #[error(\"Invalid destination address\")]\n    InvalidDestinationAddr {},\n\n    #[error(\"Invalid IBC timeout: {timeout}, must be between {min} and {max} seconds\")]\n    InvalidIBCTimeout { timeout: u64, min: u64, max: u64 },\n\n    #[error(\"Invalid contract configuration: {reason}\")]\n    InvalidConfiguration { reason: String },\n\n    #[error(\"Invalid reply ID: {id}\")]\n    InvalidReplyId { id: u64 },\n\n    #[error(\"Invalid funds, expected NTRN and bridging token to be sent together and cover bridging cost\")]\n    InvalidFunds {},\n\n    #[error(\"Insufficient funds to cover the bridging cost, expected at least {expected} untrn\")]\n    InsufficientFunds { expected: Uint128 },\n\n    #[error(\"Failed to handle IBC transfer response: {detail}\")]\n    IBCResponseFail { detail: String },\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n\nimpl From\u003cVerificationError\u003e for ContractError {\n    fn from(v: VerificationError) -\u003e Self {\n        StdError::from(v).into()\n    }\n}\n\nimpl From\u003cSignatureError\u003e for ContractError {\n    fn from(v: SignatureError) -\u003e Self {\n        let std_error = StdError::generic_err(format!(\"Signature decode error: {}\", v));\n\n        // Utilize the existing conversion from StdError to ContractError\n        ContractError::from(std_error)\n    }\n}\n\nimpl From\u003cbase64::DecodeError\u003e for ContractError {\n    fn from(error: base64::DecodeError) -\u003e Self {\n        // Convert the base64::DecodeError to a generic StdError\n        let std_error = StdError::generic_err(format!(\"Base64 decode error: {}\", error));\n\n        // Utilize the existing conversion from StdError to ContractError\n        ContractError::from(std_error)\n    }\n}\n","traces":[{"line":60,"address":[48224178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2463472],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":62,"address":[46740864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[43825913,43825502,43826131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2463536],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":68,"address":[2463557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[44089326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2463972,2463600],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":74,"address":[2463749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[44089562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2463881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[46741056,46741445,46741336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[47963545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[44089649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2464072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[44089680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2464192],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","execute.rs"],"content":"use astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{coin, entry_point, Coin, Reply, StdError, SubMsg, Uint128};\nuse cosmwasm_std::{DepsMut, Env, MessageInfo, Response};\nuse ed25519_dalek::{VerifyingKey, PUBLIC_KEY_LENGTH};\n\nuse neutron_sdk::bindings::msg::{IbcFee, MsgIbcTransferResponse, NeutronMsg};\nuse neutron_sdk::bindings::query::NeutronQuery;\nuse neutron_sdk::query::min_ibc_fee::query_min_ibc_fee;\nuse neutron_sdk::sudo::msg::RequestPacketTimeoutHeight;\nuse osmosis_std::types::cosmos::bank::v1beta1::{DenomUnit, Metadata};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::{\n    MsgBurn, MsgCreateDenom, MsgCreateDenomResponse, MsgSetDenomMetadata,\n};\n\nuse crate::helpers::{build_mint_messages, verify_signatures};\nuse crate::msg::ExecuteMsg;\nuse crate::state::{\n    BRIDGE_CURRENT_PAYLOAD, BRIDGE_INFLIGHT, DISABLED_TOKENS, HANDLED_TRANSACTIONS,\n    OWNERSHIP_PROPOSAL, SIGNERS, TOKEN_MAPPING, TOKEN_METADATA,\n};\nuse crate::types::{\n    BridgingAsset, Config, TokenMetadata, FEE_DENOM, IBC_REPLY_HANDLER_ID,\n    INSTANTIATE_DENOM_REPLY_ID, MAX_IBC_TIMEOUT_SECONDS, MIN_IBC_TIMEOUT_SECONDS,\n};\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Exposes all the execute functions available in the contract\n///\n/// ## Executable Messages\n/// * **ExecuteMsg::LinkToken { source_chain_id, token,signatures } ** Link and enable a CFT-20 token to be bridged\n/// * **ExecuteMsg::EnableToken { ticker}** Enable a previously disabled token to being bridged again\n/// * **ExecuteMsg::DisableToken { ticker }** Disable a token from being bridged\n/// * **ExecuteMsg::Receive { source_chain_id, transaction_hash, ticker, amount, destination_addr, signatures }** Receive CFT-20 token message from the Hub\n/// * **ExecuteMsg::Send { destination_addr }** Send CFT-20 token back to the Hub\n/// * **ExecuteMsg::AddSigner { public_key_base64, name }** Adds a signer to the allowed list for signature verification\n/// * **ExecuteMsg::RemoveSigner { public_key_base64 }** Remove a signer from the allowed list for signature verification\n/// * **ExecuteMsg::UpdateConfig { ibc_timeout_seconds }** Update the contract config\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Propose a new owner for the contract\n/// * **ExecuteMsg::DropOwnershipProposal {}** Remove the ownership transfer proposal\n/// * **ExecuteMsg::ClaimOwnership {}** Claim contract ownership\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    match msg {\n        ExecuteMsg::LinkToken {\n            source_chain_id,\n            token,\n            signatures,\n        } =\u003e link_token(deps, env, source_chain_id, token, signatures),\n        ExecuteMsg::EnableToken { ticker } =\u003e enable_token(deps, env, info, ticker),\n        ExecuteMsg::DisableToken { ticker } =\u003e disable_token(deps, env, info, ticker),\n        ExecuteMsg::Receive {\n            source_chain_id,\n            transaction_hash,\n            ticker,\n            amount,\n            destination_addr,\n            signatures,\n        } =\u003e bridge_receive(\n            deps,\n            env,\n            source_chain_id,\n            transaction_hash,\n            ticker,\n            amount,\n            destination_addr,\n            signatures,\n        ),\n        ExecuteMsg::Send { destination_addr } =\u003e bridge_send(deps, env, info, destination_addr),\n        ExecuteMsg::AddSigner {\n            public_key_base64,\n            name,\n        } =\u003e add_signer(deps, info, name, public_key_base64),\n        ExecuteMsg::RemoveSigner { public_key_base64 } =\u003e {\n            remove_signer(deps, env, info, public_key_base64)\n        }\n        ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel,\n            ibc_timeout_seconds,\n        } =\u003e update_config(deps, info, bridge_ibc_channel, ibc_timeout_seconds),\n        ExecuteMsg::ProposeNewOwner { owner, expires_in } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// The entry point to the contract for processing replies from submessages.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    msg: Reply,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    match msg.id {\n        INSTANTIATE_DENOM_REPLY_ID =\u003e {\n            let MsgCreateDenomResponse { new_token_denom } = msg.result.try_into()?;\n\n            let metadata = TOKEN_METADATA.load(deps.storage)?;\n\n            let denom_metadata_msg = MsgSetDenomMetadata {\n                sender: env.contract.address.to_string(),\n                metadata: Some(Metadata {\n                    symbol: metadata.ticker.clone(),\n                    name: metadata.name,\n                    base: new_token_denom.clone(),\n                    display: metadata.ticker.clone(),\n                    denom_units: vec![\n                        DenomUnit {\n                            denom: new_token_denom.clone(),\n                            exponent: 0,\n                            aliases: vec![],\n                        },\n                        DenomUnit {\n                            denom: metadata.ticker.clone(),\n                            exponent: metadata.decimals,\n                            aliases: vec![],\n                        },\n                    ],\n                    description: format!(\n                        \"{} is an Asteroid CFT-20 token bridged from the Cosmos Hub\",\n                        metadata.ticker\n                    ),\n                    uri: metadata.image_url,\n                    uri_hash: \"\".to_string(),\n                }),\n            };\n\n            // Save the mapping of TICKER \u003c\u003e DENOM both ways to ease lookups\n            // in both directions\n            TOKEN_MAPPING.save(deps.storage, \u0026metadata.ticker, \u0026new_token_denom)?;\n            TOKEN_MAPPING.save(deps.storage, \u0026new_token_denom, \u0026metadata.ticker)?;\n            TOKEN_METADATA.remove(deps.storage);\n\n            Ok(Response::new()\n                .add_message(denom_metadata_msg)\n                .add_attribute(\"action\", \"set_denom_metadata\")\n                .add_attribute(\"ticker\", metadata.ticker))\n        }\n        IBC_REPLY_HANDLER_ID =\u003e {\n            // Extract the channel and sequence ID from the IBC transfer\n            let resp: MsgIbcTransferResponse = serde_json_wasm::from_slice(\n                msg.result\n                    .into_result()\n                    .map_err(StdError::generic_err)?\n                    .data\n                    .ok_or_else(|| StdError::generic_err(\"no result\"))?\n                    .as_slice(),\n            )\n            .map_err(|e| StdError::generic_err(format!(\"failed to parse response: {:?}\", e)))?;\n            let sequence_id = resp.sequence_id;\n            let channel_id = resp.channel;\n\n            // In order to handle the success/failure sudo call for IBC transfers\n            // we need to capture the CFT-20 assets being bridged back\n            // If it fails, the tokens need to be minted and returned again\n            let payload = BRIDGE_CURRENT_PAYLOAD.load(deps.storage)?;\n            BRIDGE_INFLIGHT.save(deps.storage, (\u0026channel_id.clone(), sequence_id), \u0026payload)?;\n            BRIDGE_CURRENT_PAYLOAD.remove(deps.storage);\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"capture_ibc_transfer\")\n                .add_attribute(\"channel\", channel_id)\n                .add_attribute(\"sequence\", sequence_id.to_string()))\n        }\n        _ =\u003e Err(ContractError::InvalidReplyId { id: msg.id }),\n    }\n}\n\n/// Enable the bridging of a CFT-20 token\n///\n/// If this token doesn't have a corresponding TokenFactory token one will\n/// be created using the information provided.\nfn link_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    source_chain_id: String,\n    token: TokenMetadata,\n    signatures: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // If we already have this token, return an error\n    if TOKEN_MAPPING.has(deps.storage, \u0026token.ticker) {\n        return Err(ContractError::TokenAlreadyExists {\n            ticker: token.ticker,\n        });\n    }\n\n    // Build the attestation message to verify the token information\n    // The format is {source_chain_id}{ticker}{decimals}{chain_id}{contract_address}\n    // cosmoshub-4ticker8neutron-1neutron1xxxxx\n    let attestation = format!(\n        \"{}{}{}{}{}\",\n        source_chain_id, token.ticker, token.decimals, env.block.chain_id, env.contract.address\n    );\n\n    // Verify with current keys\n    verify_signatures(deps.as_ref(), attestation.as_bytes(), \u0026signatures)?;\n\n    // If not, create the denom and set the metadata\n    let create_denom_msg = SubMsg::reply_on_success(\n        MsgCreateDenom {\n            sender: env.contract.address.to_string(),\n            subdenom: token.ticker.clone(),\n        },\n        INSTANTIATE_DENOM_REPLY_ID,\n    );\n\n    TOKEN_METADATA.save(deps.storage, \u0026token)?;\n\n    Ok(Response::new().add_submessage(create_denom_msg))\n}\n\n/// Enable a token for bridging if it was previously disabled\nfn enable_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    ticker: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // If this token isn't in the disabled list, return an error\n    if !DISABLED_TOKENS.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"This token is not disabled\".to_string(),\n        });\n    }\n\n    DISABLED_TOKENS.remove(deps.storage, \u0026ticker);\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"enable_token\")\n        .add_attribute(\"ticker\", ticker))\n}\n\n/// Disable a token for bridging\nfn disable_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    ticker: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // If this token doesn't exist, return an error\n    if !TOKEN_MAPPING.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDoesNotExist { ticker });\n    }\n\n    DISABLED_TOKENS.save(deps.storage, \u0026ticker, \u0026true)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"disable_token\")\n        .add_attribute(\"ticker\", ticker))\n}\n\n/// Receive tokens from the Hub and mint them to the destination address\nfn bridge_receive(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    source_chain_id: String,\n    transaction_hash: String,\n    ticker: String,\n    amount: Uint128,\n    destination_addr: String,\n    signatures: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // Check if the token is disabled\n    if DISABLED_TOKENS.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDisabled { ticker });\n    }\n    // Check the amount sent, if 0, reject\n    if amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n    // Check destination address, if invalid, reject\n    if deps.api.addr_validate(\u0026destination_addr).is_err() {\n        return Err(ContractError::InvalidDestinationAddr {});\n    }\n    // Check the ticker, if it doesn't exist activate needs to be called first\n    if !TOKEN_MAPPING.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDoesNotExist { ticker });\n    }\n    // Check if we've processed this transaction already\n    if HANDLED_TRANSACTIONS.has(deps.storage, \u0026transaction_hash) {\n        return Err(ContractError::TransactionAlreadyHandled { transaction_hash });\n    }\n    // Store the transaction hash to prevent replay attacks\n    HANDLED_TRANSACTIONS.save(deps.storage, \u0026transaction_hash, \u0026true)?;\n\n    // Build the attestation message\n    let attestation = format!(\n        // source_chain_id, transaction_hash, ticker, amount\n        \"{}{}{}{}{}{}{}\",\n        source_chain_id,\n        transaction_hash,\n        ticker,\n        amount,\n        env.block.chain_id,\n        env.contract.address,\n        destination_addr\n    );\n\n    verify_signatures(deps.as_ref(), attestation.as_bytes(), \u0026signatures)?;\n\n    let tokenfactory_denom = TOKEN_MAPPING.load(deps.storage, \u0026ticker)?;\n\n    // If ticker already exists, mint new tokens to the destination\n    let coins_to_mint = coin(amount.u128(), tokenfactory_denom);\n\n    let mint_messages = build_mint_messages(\n        env.contract.address.to_string(),\n        coins_to_mint.clone(),\n        destination_addr.clone(),\n    );\n\n    Ok(Response::default()\n        .add_messages(mint_messages)\n        .add_attribute(\"action\", \"bridge_receive\")\n        .add_attribute(\"tokens\", coins_to_mint.to_string())\n        .add_attribute(\"destination\", destination_addr))\n}\n\n/// Return tokens to the Hub\nfn bridge_send(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    info: MessageInfo,\n    destination_addr: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // The user should be sending 2 tokens, one TokenFactory token to bridge back\n    // and NTRN for paying the IBC fees\n    let mut fee_coin = Coin::default();\n    let mut bridging_coin = Coin::default();\n\n    // Only the bridged token and NTRN must be sent\n    if info.funds.len() != 2 {\n        return Err(ContractError::InvalidFunds {});\n    }\n\n    info.funds.iter().for_each(|coin| {\n        if coin.denom == FEE_DENOM {\n            fee_coin = coin.clone();\n        }\n        if TOKEN_MAPPING.has(deps.storage, \u0026coin.denom) {\n            bridging_coin = coin.clone();\n        }\n    });\n\n    // If either of the coins is 0, reject\n    if fee_coin.amount.is_zero() || bridging_coin.amount.is_zero() {\n        return Err(ContractError::InvalidFunds {});\n    }\n\n    deps.api.debug(\u0026format!(\n        \"funds sent: {:?}\",\n        info.funds.iter().collect::\u003cVec\u003c_\u003e\u003e()\n    ));\n\n    // Check the mapping for this token, fail if no mapping exists\n    let cft20_denom = TOKEN_MAPPING.load(deps.storage, \u0026bridging_coin.denom)?;\n\n    // Check if the token is disabled\n    // We check the CFT-20 ticker and the TokenFactory in case one is missed in the disable\n    if DISABLED_TOKENS.has(deps.storage, \u0026cft20_denom)\n        || DISABLED_TOKENS.has(deps.storage, \u0026bridging_coin.denom)\n    {\n        return Err(ContractError::TokenDisabled {\n            ticker: cft20_denom,\n        });\n    }\n\n    // Contruct the IBC memo message to return X of denom on the Hub\n    // urn:bridge:gaialocal-1@v1;recv$tic=LOCALROIDS,amt=1,dst=cosmos1234,rch=neutronlocal-1,src=neutron1m857lgtjssgt0wm3crzfmt3v950vqnkqy4vep9\n    let memo = format!(\n        \"urn:bridge:{}@v1;recv$tic={},amt={},dst={},rch={},src={}\",\n        config.bridge_chain_id,\n        cft20_denom,\n        bridging_coin.amount,\n        destination_addr,\n        env.block.chain_id,\n        info.sender\n    );\n\n    // Burn the bridging token\n    let burn_msg = MsgBurn {\n        sender: env.contract.address.to_string(),\n        burn_from_address: env.contract.address.to_string(),\n        amount: Some(bridging_coin.clone().into()),\n    };\n\n    let fee = min_ntrn_ibc_fee(\n        query_min_ibc_fee(deps.as_ref())\n            .map_err(|err| StdError::generic_err(err.to_string()))?\n            .min_fee,\n    );\n\n    // Calculate the total fee required\n    let total_fee = fee\n        .ack_fee\n        .iter()\n        .chain(fee.recv_fee.iter())\n        .chain(fee.timeout_fee.iter())\n        .filter(|a| a.denom == FEE_DENOM)\n        .fold(Uint128::zero(), |acc, coin| acc + coin.amount);\n\n    // Ensure the user sent enough to cover the fee + 1 untrn to do the actual IBC transaction\n    let ibc_coin = coin(1u128, \"untrn\");\n    if total_fee \u003e fee_coin.amount.saturating_sub(Uint128::one()) {\n        return Err(ContractError::InsufficientFunds {\n            expected: total_fee.saturating_add(Uint128::one()),\n        });\n    }\n\n    // Construct the IBC transfer message\n    // The memo is important and enables the indexer to release the tokens on\n    // the Hub's side\n    let ibc_transfer = NeutronMsg::IbcTransfer {\n        source_port: \"transfer\".to_string(),\n        source_channel: config.bridge_ibc_channel,\n        // TODO: Note to auditor, please also confirm that this sender address can't be spoofed on the Hub's side\n        sender: env.contract.address.to_string(),\n        receiver: destination_addr.clone(),\n        token: ibc_coin,\n        timeout_height: RequestPacketTimeoutHeight {\n            revision_number: None,\n            revision_height: None,\n        },\n        // Neutron expects nanoseconds\n        // https://github.com/neutron-org/neutron/blob/303d764b57d871749fcf7d59a67b5d3078779258/proto/transfer/v1/tx.proto#L39-L42\n        timeout_timestamp: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .nanos(),\n        memo: memo.clone(),\n        fee,\n    };\n\n    // Capture the inflight asset to track the bridging to be able to handle the\n    // IBC failures\n    let inflight = BridgingAsset {\n        sender: info.sender,\n        funds: bridging_coin.clone(),\n    };\n    BRIDGE_CURRENT_PAYLOAD.save(deps.storage, \u0026inflight)?;\n\n    // Set up the submessage to capture the channel and sequence for the IBC transfer\n    let ibc_transfer_submessage = SubMsg::reply_on_success(ibc_transfer, IBC_REPLY_HANDLER_ID);\n\n    let response = Response::new()\n        .add_message(burn_msg)\n        .add_submessage(ibc_transfer_submessage)\n        .add_attribute(\"action\", \"bridge_send\")\n        .add_attribute(\"tokens\", bridging_coin.to_string())\n        .add_attribute(\"destination\", destination_addr);\n\n    Ok(response)\n}\n\n/// Add a signer to the list of allowed public keys\n/// Verifies that the public key can be loaded and in the correct format\n/// as well as checks for duplicate keys\nfn add_signer(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    info: MessageInfo,\n    name: String,\n    public_key_base64: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Decode the base64 encoded public key\n    let public_key = match general_purpose::STANDARD.decode(public_key_base64.as_bytes()) {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Key could not be decoded\".to_string(),\n            })\n        }\n    };\n\n    // Verify that the format for the key is correct before adding it\n    let public_key_bytes: [u8; PUBLIC_KEY_LENGTH] = match public_key.clone().try_into() {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Invalid public key length\".to_string(),\n            });\n        }\n    };\n    VerifyingKey::from_bytes(\u0026public_key_bytes)?;\n\n    // Ensure this key isn't loaded yet\n    if SIGNERS.has(deps.storage, \u0026public_key) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The public key has already been loaded\".to_string(),\n        });\n    }\n\n    SIGNERS.save(deps.storage, \u0026public_key, \u0026name)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"add_signer\")\n        .add_attribute(\"name\", name)\n        .add_attribute(\"public_key\", public_key_base64))\n}\n\n/// Remove a signer from the list of allowed public keys\nfn remove_signer(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    public_key_base64: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Decode the base64 encoded public key\n    let public_key = match general_purpose::STANDARD.decode(public_key_base64.as_bytes()) {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Key could not be decoded\".to_string(),\n            })\n        }\n    };\n\n    if !SIGNERS.has(deps.storage, \u0026public_key) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"Key to remove doesn't exist\".to_string(),\n        });\n    }\n\n    SIGNERS.remove(deps.storage, \u0026public_key);\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"remove_signer\")\n        .add_attribute(\"public_key\", public_key_base64))\n}\n\n/// Update the Bridge config\nfn update_config(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    info: MessageInfo,\n    bridge_ibc_channel: Option\u003cString\u003e,\n    ibc_timeout_seconds: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Allow changing the IBC channel in case the original channel expires\n    // and can't be revived\n    if let Some(bridge_ibc_channel) = bridge_ibc_channel {\n        if bridge_ibc_channel.is_empty() {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"The bridge IBC channel must be specified\".to_string(),\n            });\n        }\n\n        config.bridge_ibc_channel = bridge_ibc_channel;\n    }\n\n    // Validate minimum and maximum IBC timeout\n    if let Some(ibc_timeout_seconds) = ibc_timeout_seconds {\n        if !(MIN_IBC_TIMEOUT_SECONDS..=MAX_IBC_TIMEOUT_SECONDS).contains(\u0026ibc_timeout_seconds) {\n            return Err(ContractError::InvalidIBCTimeout {\n                timeout: ibc_timeout_seconds,\n                min: MIN_IBC_TIMEOUT_SECONDS,\n                max: MAX_IBC_TIMEOUT_SECONDS,\n            });\n        }\n        config.ibc_timeout_seconds = ibc_timeout_seconds;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Helper function to query the Neutron chain for the current minimum IBC fees\nfn min_ntrn_ibc_fee(fee: IbcFee) -\u003e IbcFee {\n    IbcFee {\n        recv_fee: fee.recv_fee,\n        ack_fee: fee\n            .ack_fee\n            .into_iter()\n            .filter(|a| a.denom == FEE_DENOM)\n            .collect(),\n        timeout_fee: fee\n            .timeout_fee\n            .into_iter()\n            .filter(|a| a.denom == FEE_DENOM)\n            .collect(),\n    }\n}\n\n#[cfg(test)]\nmod testing {\n    use std::marker::PhantomData;\n\n    use cosmwasm_std::testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage};\n    use cosmwasm_std::{\n        coins, to_json_binary, ContractResult, CosmosMsg, OwnedDeps, SubMsg, SystemResult,\n    };\n    use neutron_sdk::query::min_ibc_fee::MinIbcFeeResponse;\n\n    use crate::contract::instantiate;\n    use crate::msg::InstantiateMsg;\n\n    use super::*;\n\n    pub const OWNER: \u0026str = \"owner\";\n    pub const NOT_OWNER: \u0026str = \"not_owner\";\n    pub const USER: \u0026str = \"cosmos_user\";\n\n    fn mock_neutron_dependencies(\n        balances: \u0026[(\u0026str, \u0026[Coin])],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003cNeutronQuery\u003e, NeutronQuery\u003e {\n        let neutron_custom_handler = |request: \u0026NeutronQuery| {\n            let contract_result: ContractResult\u003c_\u003e = match request {\n                NeutronQuery::MinIbcFee {} =\u003e to_json_binary(\u0026MinIbcFeeResponse {\n                    min_fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                })\n                .into(),\n                _ =\u003e unimplemented!(\"Unsupported query request: {:?}\", request),\n            };\n            SystemResult::Ok(contract_result)\n        };\n\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(balances).with_custom_handler(neutron_custom_handler),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    #[test]\n    fn test_bridge_send() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        TOKEN_MAPPING\n            .save(\n                deps.as_mut().storage,\n                \"TESTTOKEN\",\n                \u0026\"factory/contract0/TESTTOKEN\".to_string(),\n            )\n            .unwrap();\n\n        TOKEN_MAPPING\n            .save(\n                deps.as_mut().storage,\n                \"factory/contract0/TESTTOKEN\",\n                \u0026\"TESTTOKEN\".to_string(),\n            )\n            .unwrap();\n\n        // Test with correct funds\n        let info = mock_info(\n            NOT_OWNER,\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(100u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(200_001u64),\n                },\n            ],\n        );\n        let response =\n            bridge_send(deps.as_mut(), mock_env(), info.clone(), USER.to_owned()).unwrap();\n\n        // Verify the tokens are burned\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgBurn {\n                sender: env.contract.address.to_string(),\n                burn_from_address: env.contract.address.to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: \"100\".to_string(),\n                }),\n            }),\n        );\n\n        // Verify the memo sent is correct\n        assert_eq!(response.messages[1].msg,CosmosMsg::Custom(NeutronMsg::IbcTransfer {\n                    source_port: \"transfer\".to_string(),\n                    source_channel: \"channel-1\".to_string(),\n                    sender: env.contract.address.to_string(),\n                    receiver: USER.to_string(),\n                    token: coin(1, \"untrn\"),\n                    timeout_height: RequestPacketTimeoutHeight {\n                        revision_number: None,\n                        revision_height: None,\n                    },\n                    timeout_timestamp: env.block.time.plus_seconds(300).nanos(),\n                    memo: \"urn:bridge:localgaia-1@v1;recv$tic=TESTTOKEN,amt=100,dst=cosmos_user,rch=cosmos-testnet-14002,src=not_owner\".to_string(),\n                    fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                }))\n    }\n}\n","traces":[{"line":43,"address":[2605648,2609550,2608566],"length":1,"stats":{"Line":7},"fn_name":"execute"},{"line":49,"address":[2605685],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[2605810],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[2607747,2606028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[2607749,2606221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2606533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2606561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2606729,2607753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2606917],"length":1,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[2607067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[2607091,2607757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2607279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2607382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2607431,2607815,2608313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2608043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2608086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2608153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2608193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[2608729,2609082,2607468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[2608947,2609225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2284624],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":106,"address":[2284688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2284940,2284752,2284655],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":108,"address":[2284782,2284866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2284892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2284977,2284976],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":120,"address":[2613544,2616248,2609584],"length":1,"stats":{"Line":4},"fn_name":"reply"},{"line":125,"address":[2609646],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2609847,2610198,2613715,2610054],"length":1,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[2610158,2610613,2610347,2613691],"length":1,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[2610579],"length":1,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[2612090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[2612737,2612464,2612591,2613447],"length":1,"stats":{"Line":8},"fn_name":null},{"line":162,"address":[2612687,2612971,2613426,2612846],"length":1,"stats":{"Line":8},"fn_name":null},{"line":163,"address":[2612942],"length":1,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[2613068,2613139,2613234],"length":1,"stats":{"Line":12},"fn_name":null},{"line":166,"address":[2613075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[2613194],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[2613733,2614022,2616193,2609921,2614091,2614311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2613958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[2284992,2285004],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":180,"address":[2285134,2285040],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":181,"address":[2614776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2614792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2615139,2614926,2614840,2616088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2615084,2615276,2616035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2615600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2615629,2615910,2615843,2615724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2615767,2615684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2615775,2615902,2616025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2609774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[2579552,2581933,2582239],"length":1,"stats":{"Line":3},"fn_name":"link_token"},{"line":212,"address":[2579627,2579773],"length":1,"stats":{"Line":6},"fn_name":null},{"line":213,"address":[2579950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[2579907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[2580533,2580405,2580199,2580308],"length":1,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[2580782,2580723,2580978,2581944],"length":1,"stats":{"Line":8},"fn_name":null},{"line":231,"address":[2581138],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[2580947],"length":1,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[2581075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[2581254,2581324,2581399],"length":1,"stats":{"Line":8},"fn_name":null},{"line":240,"address":[2581384,2581488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":244,"address":[2583466,2583568,2582256],"length":1,"stats":{"Line":1},"fn_name":"enable_token"},{"line":250,"address":[2582395,2582293,2582631,2583477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[2582600,2582764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[2582819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[2582780,2582889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[2583342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[2582960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[2582927,2583009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[2583122,2583031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[2583091],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[2583584,2584993,2585111],"length":1,"stats":{"Line":1},"fn_name":"disable_token"},{"line":278,"address":[2583624,2583726,2585004,2583962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[2584095,2583931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[2584150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[2584220,2584111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[2584305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[2584964,2584573,2584258,2584466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[2584746,2584662,2584561],"length":1,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[2584715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[2589871,2590240,2585136],"length":1,"stats":{"Line":1},"fn_name":"bridge_receive"},{"line":309,"address":[2585477,2585267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[2585556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[2585707,2585511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[2585784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[2585869,2585729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[2586053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[2585999,2586138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[2586253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[2586188,2586429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[2586544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[2586720,2590014,2586896,2586479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[2587358,2587759,2587473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[2588040,2589993,2587981,2588255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":346,"address":[2588213,2588550,2588364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[2588510,2588690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[2588828,2588761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[2588852,2588905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[2588913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[2589398,2589057,2589300,2589169],"length":1,"stats":{"Line":4},"fn_name":null},{"line":358,"address":[2589105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[2589224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[2589232,2589359,2589861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[2589367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[2597927,2598969,2590256],"length":1,"stats":{"Line":2},"fn_name":"bridge_send"},{"line":371,"address":[2590513,2598740,2590331,2590747],"length":1,"stats":{"Line":4},"fn_name":null},{"line":375,"address":[2590729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[2590888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[2590944,2591016],"length":1,"stats":{"Line":4},"fn_name":null},{"line":380,"address":[2591069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[2284257,2283904],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":384,"address":[2284135,2283947],"length":1,"stats":{"Line":4},"fn_name":null},{"line":385,"address":[2284038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[2283973,2284255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":388,"address":[2284158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[2591259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[2591439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[2591655,2591376,2591979],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[2591400,2591508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[2592014,2598448,2592323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[2592584,2592488,2592654,2592258],"length":1,"stats":{"Line":6},"fn_name":null},{"line":408,"address":[2592530,2592626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[2592821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[2592765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[2592673,2593295,2593577,2593065],"length":1,"stats":{"Line":4},"fn_name":null},{"line":429,"address":[2593775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2593850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[2593994,2593930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[2594598,2594185,2598356,2594233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[2284272,2284295],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":441,"address":[2594900,2594631,2594723,2595017,2595094],"length":1,"stats":{"Line":5},"fn_name":null},{"line":444,"address":[2594782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[2594907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[2284400,2284414],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":447,"address":[2284498,2284448],"length":1,"stats":{"Line":3},"fn_name":"{closure#3}"},{"line":450,"address":[2595149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[2595304,2595186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[2598158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[2598121,2595419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[2595392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[2595473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[2595513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[2595588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[2595736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[2595800,2595812,2595873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":478,"address":[2595901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[2596365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[2596412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[2596756,2596551,2596628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[2596680,2596845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":493,"address":[2597239,2596861,2597108,2597037,2597337],"length":1,"stats":{"Line":5},"fn_name":null},{"line":494,"address":[2596909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[2597044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[2597946,2597171,2597298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[2597306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[2597388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[2601478,2601204,2598992],"length":1,"stats":{"Line":6},"fn_name":"add_signer"},{"line":512,"address":[2599038,2599156,2599395,2601340],"length":1,"stats":{"Line":12},"fn_name":null},{"line":515,"address":[2599528,2599361],"length":1,"stats":{"Line":12},"fn_name":null},{"line":516,"address":[2599564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2599627,2599539],"length":1,"stats":{"Line":12},"fn_name":null},{"line":521,"address":[2599678],"length":1,"stats":{"Line":5},"fn_name":null},{"line":523,"address":[2601223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[2599769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[2599859,2599742],"length":1,"stats":{"Line":7},"fn_name":null},{"line":531,"address":[2599884],"length":1,"stats":{"Line":6},"fn_name":null},{"line":533,"address":[2601073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[2599963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[2600009,2600146,2601020],"length":1,"stats":{"Line":6},"fn_name":null},{"line":541,"address":[2600092,2600215],"length":1,"stats":{"Line":12},"fn_name":null},{"line":542,"address":[2600922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[2600297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[2600251,2600352,2600890,2600455],"length":1,"stats":{"Line":12},"fn_name":null},{"line":549,"address":[2600440,2600544,2600628,2600707],"length":1,"stats":{"Line":24},"fn_name":null},{"line":551,"address":[2600597],"length":1,"stats":{"Line":6},"fn_name":null},{"line":552,"address":[2600676],"length":1,"stats":{"Line":6},"fn_name":null},{"line":556,"address":[2601504,2603000,2603227],"length":1,"stats":{"Line":1},"fn_name":"remove_signer"},{"line":562,"address":[2603136,2601547,2601888,2601649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":565,"address":[2602021,2601854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[2602057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[2602120,2602032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[2602176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[2603019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[2602286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[2602380,2602240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[2602868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[2602458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[2602507,2602413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":587,"address":[2602529,2602620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":589,"address":[2602589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":593,"address":[2605129,2604388,2603248],"length":1,"stats":{"Line":1},"fn_name":"update_config"},{"line":599,"address":[2603290,2605055,2603643,2603419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[2603615,2603773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":603,"address":[2603815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[2603784,2604216,2603870],"length":1,"stats":{"Line":3},"fn_name":null},{"line":609,"address":[2603917,2603990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[2604226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[2604055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[2603996,2604085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[2604503,2603928,2604399],"length":1,"stats":{"Line":3},"fn_name":null},{"line":620,"address":[2604412,2604481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[2604518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[2604510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[2604487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[2603280,2605019,2604443,2604672,2604600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":632,"address":[2604761,2604660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":636,"address":[2605588,2605609,2605152],"length":1,"stats":{"Line":1},"fn_name":"min_ntrn_ibc_fee"},{"line":638,"address":[2605174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[2605306,2605207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[2605335,2605451],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":179,"coverable":211},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","helpers.rs"],"content":"use base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{BankMsg, Coin, CosmosMsg, Deps, Order};\nuse neutron_sdk::bindings::{msg::NeutronMsg, query::NeutronQuery};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::MsgMint;\n\nuse crate::{error::ContractError, state::SIGNERS, types::MIN_SIGNER_THRESHOLD};\n\n/// Verify the signatures against the current loaded public keys\n/// Once we reach the valid threshold, we return Ok\n/// If we don't have enough valid signatures, we return Err\npub fn verify_signatures(\n    deps: Deps\u003cNeutronQuery\u003e,\n    message: \u0026[u8],\n    signatures: \u0026[String],\n) -\u003e Result\u003c(), ContractError\u003e {\n    // If no signatures were sent, fail the verification\n    if signatures.is_empty() {\n        return Err(ContractError::ThresholdNotMet {});\n    }\n\n    // If duplicate signatures are sent, fail the verification\n    let mut unique_signatures = signatures.to_vec();\n    unique_signatures.sort();\n    unique_signatures.dedup();\n    if unique_signatures.len() != signatures.len() {\n        return Err(ContractError::DuplicateSignatures {});\n    }\n\n    // Calculate the threshold based on the number of signers\n    let keys = SIGNERS.keys(deps.storage, None, None, Order::Ascending);\n    let majority_threshold = get_majority_threshold(keys.count());\n\n    // If the number of unique signatures are less than the threshold, fail the verification\n    if unique_signatures.len() \u003c majority_threshold.into() {\n        return Err(ContractError::ThresholdNotMet {});\n    }\n\n    // Load the current allowed public keys\n    let allowed_keys = SIGNERS.keys(deps.storage, None, None, Order::Ascending);\n\n    let mut verified_signatures = 0;\n\n    // Decode signatures from base64\n    let decoded_signatures: Result\u003cVec\u003c_\u003e, _\u003e = unique_signatures\n        .iter()\n        .map(|sig| general_purpose::STANDARD.decode(sig))\n        .collect();\n    let decoded_signatures = decoded_signatures?;\n\n    // Verify the signatures against the loaded keys\n    // This requires iterating over the signatures and the loaded keys\n    // and thus we should not keep too many keys loaded\n    //\n    // While there is a possbility for this to be unbounded, the number of keys\n    // will be small. The decision to use this method vs\n    // sending keys with their signatures was made to simplify interactions\n    // with the contract\n    for loaded_key in allowed_keys {\n        let allowed_key = loaded_key?;\n\n        for signature in \u0026decoded_signatures {\n            let is_valid = deps.api.ed25519_verify(message, signature, \u0026allowed_key)?;\n            if is_valid {\n                verified_signatures += 1;\n                if verified_signatures \u003e= majority_threshold {\n                    return Ok(());\n                }\n                // We can move on to the next key and signatures\n                break;\n            }\n        }\n    }\n    // If we reach this point, we did not have enough valid signatures\n    Err(ContractError::ThresholdNotMet {})\n}\n\n/// Construct messages to mint and transfer TokenFactory tokens\n/// TokenFactory tokens must always be minted by the contract address\npub fn build_mint_messages(\n    contract_address: String,\n    coin: Coin,\n    destination: String,\n) -\u003e Vec\u003cCosmosMsg\u003cNeutronMsg\u003e\u003e {\n    // TokenFactory can only mint to the sender\n    let mint_msg = MsgMint {\n        sender: contract_address.clone(),\n        amount: Some(coin.clone().into()),\n        mint_to_address: contract_address,\n    };\n\n    // Once minted to self, transfer to destination\n    let mint_transfer = BankMsg::Send {\n        to_address: destination,\n        amount: vec![coin.clone()],\n    };\n\n    vec![mint_msg.into(), mint_transfer.into()]\n}\n\n/// Get the majority threshold for the current amount of signers\n/// If the amount if an even number, we return the threshold as half of the signers + 1\n/// If the amount is an odd number, we return the threshold as half of the signers rounded up\n/// to the nearest integer\n/// If the threshold is less than the minimum threshold, we return the minimum threshold\npub fn get_majority_threshold(signers_count: usize) -\u003e u8 {\n    let threshold = if signers_count % 2 == 0 {\n        (signers_count / 2) + 1\n    } else {\n        (signers_count + 1) / 2\n    };\n\n    // Ensure the threshold is not less than MIN_SIGNER_THRESHOLD\n    threshold\n        .try_into()\n        .unwrap_or(MIN_SIGNER_THRESHOLD)\n        .max(MIN_SIGNER_THRESHOLD)\n}\n\n#[cfg(test)]\nmod testing {\n    use super::*;\n\n    #[test]\n    fn test_threshold_calculation() {\n        // Test the threshold calculation\n        assert_eq!(get_majority_threshold(0), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(1), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(2), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(3), 2);\n        assert_eq!(get_majority_threshold(4), 3);\n        assert_eq!(get_majority_threshold(5), 3);\n        assert_eq!(get_majority_threshold(6), 4);\n        assert_eq!(get_majority_threshold(7), 4);\n        assert_eq!(get_majority_threshold(8), 5);\n        assert_eq!(get_majority_threshold(9), 5);\n        assert_eq!(get_majority_threshold(10), 6);\n\n        assert_eq!(get_majority_threshold(50), 26);\n        assert_eq!(get_majority_threshold(51), 26);\n\n        assert_eq!(get_majority_threshold(99), 50);\n        assert_eq!(get_majority_threshold(100), 51);\n    }\n}\n","traces":[{"line":11,"address":[2741968,2744519,2744627],"length":1,"stats":{"Line":3},"fn_name":"verify_signatures"},{"line":16,"address":[34397440,34397497,34397152,34397177,34397255,34397395,34397376,34397216,34397408,34397416,34397328,34397443,34397472,34397296],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":17,"address":[2742085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[34050832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[34397137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[34050864,34051502,34051589],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[34051326],"length":1,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[2742287],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[2742294],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[2742452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[34050918,34051483,34051581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2742350,2742502],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[2742518],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[2742569],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[2742752],"length":1,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[2742802,2742650],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[2742826],"length":1,"stats":{"Line":28},"fn_name":null},{"line":43,"address":[35237191,35237613,35237677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2742926,2742834],"length":1,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[2337653,2337632],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":48,"address":[2743023,2743223,2744563],"length":1,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[34051616],"length":1,"stats":{"Line":16},"fn_name":null},{"line":51,"address":[34051649],"length":1,"stats":{"Line":8},"fn_name":null},{"line":52,"address":[34051667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[44170275,44170185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[34051696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[34051724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[34051738],"length":1,"stats":{"Line":18},"fn_name":null},{"line":58,"address":[2743321,2743171,2744512],"length":1,"stats":{"Line":20},"fn_name":null},{"line":59,"address":[2743780,2743501,2743651,2744530],"length":1,"stats":{"Line":16},"fn_name":null},{"line":61,"address":[2743923,2743740,2744035],"length":1,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[2744502,2744051,2744343],"length":1,"stats":{"Line":12},"fn_name":null},{"line":63,"address":[2744326],"length":1,"stats":{"Line":42},"fn_name":null},{"line":64,"address":[2744385,2744437],"length":1,"stats":{"Line":23},"fn_name":null},{"line":65,"address":[2744423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[2744477],"length":1,"stats":{"Line":37},"fn_name":null},{"line":68,"address":[44170820],"length":1,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[35238879],"length":1,"stats":{"Line":7},"fn_name":null},{"line":74,"address":[2743536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[2746159,2746050,2744656],"length":1,"stats":{"Line":13},"fn_name":"build_mint_messages"},{"line":84,"address":[35239152],"length":1,"stats":{"Line":7},"fn_name":"encode_length"},{"line":86,"address":[2744736],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[2744809,2744873],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[2745121,2745187,2746100],"length":1,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[2746061,2745466,2745524],"length":1,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[2746192],"length":1,"stats":{"Line":5},"fn_name":"get_majority_threshold"},{"line":106,"address":[2746372,2746206,2746275],"length":1,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[2746270,2746221,2746277],"length":1,"stats":{"Line":10},"fn_name":null},{"line":109,"address":[2746374,2746248,2746363],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[2746307],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":42,"coverable":50},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod helpers;\npub mod msg;\npub mod query;\npub mod state;\npub mod sudo;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","msg.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Uint128;\n\nuse crate::types::{Config, QuerySignersResponse, QueryTokensResponse, TokenMetadata};\n\n/// Holds the parameters used for creating a Hub contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: String,\n    /// The IBC channel to the Cosmos Hub\n    pub bridge_ibc_channel: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: Option\u003cString\u003e,\n}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Link and enable a CFT-20 token to be bridged\n    LinkToken {\n        /// The chain ID of the source chain\n        source_chain_id: String,\n        /// The metadata of the CFT-20 token\n        token: TokenMetadata,\n        /// The signatures of from the verifying parties\n        signatures: Vec\u003cString\u003e,\n    },\n    // Enable a previously disabled token to being bridged again\n    EnableToken {\n        /// The ticker of the CFT-20 token\n        ticker: String,\n    },\n    // Disable a token from being bridged\n    DisableToken {\n        /// The ticker of the CFT-20 token\n        ticker: String,\n    },\n    /// Receive CFT-20 token message from the Hub\n    Receive {\n        /// The chain ID of the source chain\n        source_chain_id: String,\n        /// The hash of the transaction on the origin chain\n        transaction_hash: String,\n        /// The ticker of the CFT-20 token\n        ticker: String,\n        /// The amount of CFT-20 tokens\n        amount: Uint128,\n        /// The destination address to transfer the CFT-20-equivalent to\n        destination_addr: String,\n        /// The signatures of from the verifying parties\n        signatures: Vec\u003cString\u003e,\n    },\n    /// Send CFT-20 token back to the Hub\n    Send {\n        /// The destination address to transfer the CFT-20-equivalent to\n        destination_addr: String,\n    },\n    /// Adds a signer to the allowed list for signature verification\n    AddSigner {\n        /// The public key in base64. This is the raw key without the ASN.1\n        /// structure, that is, the last 32 bytes from the DER-encoded public key\n        public_key_base64: String,\n        /// A simple human name for the owner of the public key\n        name: String,\n    },\n    /// Remove a signer from the allowed list for signature verification\n    RemoveSigner {\n        /// The public key in base64 to remove. This is the same key added using\n        /// AddSigner\n        public_key_base64: String,\n    },\n    /// Update the contract config\n    UpdateConfig {\n        /// The IBC channel to the Cosmos Hub\n        bridge_ibc_channel: Option\u003cString\u003e,\n        /// The timeout in seconds for IBC packets\n        ibc_timeout_seconds: Option\u003cu64\u003e,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner {\n        /// The owner being proposed\n        owner: String,\n        /// Time in seconds for the proposal to expire\n        expires_in: u64,\n    },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Bridge\n    #[returns(Config)]\n    Config {},\n    /// Returns the allowed signers for signature verification\n    #[returns(QuerySignersResponse)]\n    Signers {},\n    /// Returns all the tokens that have been added to the bridge\n    #[returns(QueryTokensResponse)]\n    Tokens {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Returns the disabled tokens\n    #[returns(QueryTokensResponse)]\n    DisabledTokens {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","query.rs"],"content":"use crate::state::{CONFIG, DISABLED_TOKENS, TOKEN_MAPPING};\nuse crate::types::{QuerySignersResponse, QueryTokensResponse};\nuse crate::{msg::QueryMsg, state::SIGNERS};\nuse base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{entry_point, to_json_binary, Binary, Deps, Env, Order, StdError, StdResult};\nuse cw_storage_plus::Bound;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\n// Settings for pagination.\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns the config of the Bridge\n/// * **QueryMsg::Signers {}** Returns the current signers and their public keys in base64\n/// * **QueryMsg::Tokens { start_after, limit }** Returns the CFT-20 and TokenFactory tokens that can be bridged\n/// * **QueryMsg::DisabledTokens { start_after, limit }** Returns the CFT-20 and TokenFactory tokens that have been disabled from bridging},\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps\u003cNeutronQuery\u003e, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_json_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Signers {} =\u003e {\n            let signers: Result\u003cVec\u003c_\u003e, StdError\u003e = SIGNERS\n                .range(deps.storage, None, None, Order::Ascending)\n                .map(|result| {\n                    result.map(|(key, value)| (general_purpose::STANDARD.encode(key), value))\n                })\n                .collect();\n\n            match signers {\n                Ok(signers) =\u003e to_json_binary(\u0026QuerySignersResponse { signers }),\n                Err(e) =\u003e Err(e),\n            }\n        }\n        QueryMsg::Tokens { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_all_tokens(deps, start_after, limit)?)\n        }\n        QueryMsg::DisabledTokens { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_disabled_tokens(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Queries all tokens that have been added to the bridge\npub fn query_all_tokens(\n    deps: Deps\u003cNeutronQuery\u003e,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cQueryTokensResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start_bound = start_after.as_deref().map(Bound::exclusive);\n\n    let tokens = TOKEN_MAPPING\n        .keys(deps.storage, start_bound, None, Order::Ascending)\n        .take(limit)\n        .map(|key_result| key_result.map_err(StdError::from))\n        .collect::\u003cStdResult\u003cVec\u003cString\u003e\u003e\u003e()?;\n\n    Ok(QueryTokensResponse { tokens })\n}\n\n/// Queries all disabled tokens\npub fn query_disabled_tokens(\n    deps: Deps\u003cNeutronQuery\u003e,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cQueryTokensResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start_bound = start_after.as_deref().map(Bound::exclusive);\n\n    let tokens = DISABLED_TOKENS\n        .keys(deps.storage, start_bound, None, Order::Ascending)\n        .take(limit)\n        .map(|key_result| key_result.map_err(StdError::from))\n        .collect::\u003cStdResult\u003cVec\u003cString\u003e\u003e\u003e()?;\n\n    Ok(QueryTokensResponse { tokens })\n}\n","traces":[{"line":21,"address":[2314400,2315270,2316161],"length":1,"stats":{"Line":1},"fn_name":"query"},{"line":22,"address":[2314432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2314903,2314468,2315281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[34059880,34062409,34059912,34062364,34062454,34060946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[34059933,34059895,34060961,34062384,34062429,34062460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[2314505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2442464],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":28,"address":[2442512,2442492,2442528],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":32,"address":[2315349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2315379,2315520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[2315458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[34062826,34061248,34060168,34062691,34062760,34060129],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[2315854,2315586,2314652],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[2314731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[34855718,34854854,34855775,34855832,34853829,34853786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2313615,2312896],"length":1,"stats":{"Line":3},"fn_name":"query_all_tokens"},{"line":52,"address":[2312960,2313030],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[2313065],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[2313165,2313567],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[2313109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[2442368,2442396],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":61,"address":[34891211,34891751],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[2314367,2313648],"length":1,"stats":{"Line":1},"fn_name":"query_disabled_tokens"},{"line":70,"address":[34895843,34894344,34894436,34895981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[2313817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2314319,2313917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2313861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[34621368,34621703,34621564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2442444,2442416],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":79,"address":[2314152],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":30},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse crate::types::{BridgingAsset, Config, TokenMetadata};\n\nuse astroport::common::OwnershipProposal;\n\n/// Store the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// The public keys of the allowed signers of bridge messages used to confirm\n/// signature. The public key is stored in the format required during bridging\n/// It holds \u003cpublic key, name\u003e to help identify specific keys\npub const SIGNERS: Map\u003c\u0026[u8], String\u003e = Map::new(\"signers\");\n\n// Token Mapping is kept in a map of\n// CFT-20 Ticker -\u003e TokenFactory denom as well as the reverse\n// TokenFactory denom -\u003e CFT-20 Ticker\npub const TOKEN_MAPPING: Map\u003c\u0026str, String\u003e = Map::new(\"token_mapping\");\n\n/// Store the disabled tokens\npub const DISABLED_TOKENS: Map\u003c\u0026str, bool\u003e = Map::new(\"disabled_tokens\");\n\n/// Store the transactions we've processed\npub const HANDLED_TRANSACTIONS: Map\u003c\u0026str, bool\u003e = Map::new(\"handled_transactions\");\n\n/// Store the token metadata when the denom is created via Reply\npub const TOKEN_METADATA: Item\u003cTokenMetadata\u003e = Item::new(\"token_metadata\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Holds the bridging assets that are currently in flight\npub const BRIDGE_INFLIGHT: Map\u003c(\u0026str, u64), BridgingAsset\u003e = Map::new(\"bridge_inflight\");\n\n/// Temporary storage for the payload of the current bridge message for handling replies\npub const BRIDGE_CURRENT_PAYLOAD: Item\u003cBridgingAsset\u003e = Item::new(\"bridge_current_payload\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","sudo.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, Response};\nuse neutron_sdk::{\n    bindings::{msg::NeutronMsg, query::NeutronQuery},\n    sudo::msg::TransferSudoMsg,\n};\n\nuse crate::{error::ContractError, helpers::build_mint_messages, state::BRIDGE_INFLIGHT};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn sudo(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    msg: TransferSudoMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // Neutron requires sudo endpoint to be implemented to handle success and\n    // failures of the IBC transfers\n    // We use this to mint and return the funds to the sender in case of an error\n    // by storing the currently in-flight assets in the contract state\n    // based on channel and sequence id\n    match msg {\n        TransferSudoMsg::Response { request, .. } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in success\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in success\".to_string(),\n                })?;\n\n            // The IBC transfer succeeded, we can remove the bridging asset from the in-flight\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"success on sequence {:?}\", sequence_id)))\n        }\n        TransferSudoMsg::Error { request, .. } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in error\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in error\".to_string(),\n                })?;\n\n            // Get the assets being bridged for this channel and sequence\n            // We need to mint and return the funds to the sender\n            let payload = BRIDGE_INFLIGHT.load(deps.storage, (\u0026channel_id, sequence_id))?;\n\n            let mint_messages = build_mint_messages(\n                env.contract.address.to_string(),\n                payload.funds.clone(),\n                payload.sender.to_string(),\n            );\n\n            // Remove the in-flight asset as it has been handled\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_messages(mint_messages)\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"error on sequence {:?}\", sequence_id)))\n        }\n        TransferSudoMsg::Timeout { request } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in timeout\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in timeout\".to_string(),\n                })?;\n\n            // Get the assets being bridged for this channel and sequence\n            // We need to mint and return the funds to the sender\n            let payload = BRIDGE_INFLIGHT.load(deps.storage, (\u0026channel_id, sequence_id))?;\n\n            let mint_messages = build_mint_messages(\n                env.contract.address.to_string(),\n                payload.funds.clone(),\n                payload.sender.to_string(),\n            );\n\n            // Remove the in-flight asset as it has been handled\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_messages(mint_messages)\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"timeout on sequence {:?}\", sequence_id)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod testing {\n    use std::marker::PhantomData;\n\n    use cosmwasm_std::testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage};\n    use cosmwasm_std::{\n        coin, coins, to_json_binary, Addr, BankMsg, Coin, ContractResult, OwnedDeps, SubMsg,\n        SystemResult,\n    };\n    use neutron_sdk::bindings::msg::IbcFee;\n    use neutron_sdk::query::min_ibc_fee::MinIbcFeeResponse;\n    use neutron_sdk::sudo::msg::RequestPacket;\n    use osmosis_std::types::osmosis::tokenfactory::v1beta1::MsgMint;\n\n    use crate::contract::instantiate;\n    use crate::msg::InstantiateMsg;\n    use crate::sudo::sudo;\n    use crate::types::{BridgingAsset, FEE_DENOM};\n\n    use super::*;\n\n    pub const OWNER: \u0026str = \"owner\";\n    pub const USER: \u0026str = \"cosmos_user\";\n\n    fn mock_neutron_dependencies(\n        balances: \u0026[(\u0026str, \u0026[Coin])],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003cNeutronQuery\u003e, NeutronQuery\u003e {\n        let neutron_custom_handler = |request: \u0026NeutronQuery| {\n            let contract_result: ContractResult\u003c_\u003e = match request {\n                NeutronQuery::MinIbcFee {} =\u003e to_json_binary(\u0026MinIbcFeeResponse {\n                    min_fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                })\n                .into(),\n                _ =\u003e unimplemented!(\"Unsupported query request: {:?}\", request),\n            };\n            SystemResult::Ok(contract_result)\n        };\n\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(balances).with_custom_handler(neutron_custom_handler),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    #[test]\n    fn test_bridge_sudo_success() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(100, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in success\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in success\".to_string()\n            }\n        );\n\n        sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap();\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n\n    #[test]\n    fn test_bridge_sudo_error() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(100, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in error\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in error\".to_string()\n            }\n        );\n\n        let response = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Verify the tokens are minted\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgMint {\n                sender: \"cosmos2contract\".to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    amount: \"100\".to_string(),\n                    denom: \"factory/contract0/TESTTOKEN\".to_string()\n                }),\n                mint_to_address: \"cosmos2contract\".to_string()\n            }),\n        );\n\n        // And sent to the original sender\n        assert_eq!(\n            response.messages[1],\n            SubMsg::new(BankMsg::Send {\n                to_address: USER.to_string(),\n                amount: coins(100u128, \"factory/contract0/TESTTOKEN\".to_string())\n            })\n        );\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n\n    #[test]\n    fn test_bridge_sudo_timeout() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(1000, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in timeout\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in timeout\".to_string()\n            }\n        );\n\n        let response = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap();\n\n        // Verify the tokens are minted\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgMint {\n                sender: \"cosmos2contract\".to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    amount: \"1000\".to_string(),\n                    denom: \"factory/contract0/TESTTOKEN\".to_string()\n                }),\n                mint_to_address: \"cosmos2contract\".to_string()\n            }),\n        );\n\n        // And sent to the original sender\n        assert_eq!(\n            response.messages[1],\n            SubMsg::new(BankMsg::Send {\n                to_address: USER.to_string(),\n                amount: coins(1000u128, \"factory/contract0/TESTTOKEN\".to_string())\n            })\n        );\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n}\n","traces":[{"line":10,"address":[2301422,2299520,2307024],"length":1,"stats":{"Line":3},"fn_name":"sudo"},{"line":20,"address":[2299582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[2299703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2299729,2301489,2300233,2300031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[2403486,2403440],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[2403454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2300127,2300318,2300508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[2403582,2403536],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":32,"address":[2403550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[2300382,2300565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2301005,2300938,2300627],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[2300682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2300997,2301441,2300771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2299795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2299821,2304051,2302049,2301847],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[2403632,2403678],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":47,"address":[2403646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2304030,2302324,2302134,2301943],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2403774,2403728],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":53,"address":[2403742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[2302198,2302381,2302651,2304009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2302617,2302780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[2302849,2302788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2302857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2303112,2303009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[2303174,2303611,2303544,2303245],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[2303181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2303300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2303937,2303603,2303383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2299887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2304561,2306659,2299913,2304359],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[2403870,2403824],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":79,"address":[2403838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2304646,2306638,2304824,2304455],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[2403966,2403920],"length":1,"stats":{"Line":2},"fn_name":"{closure#5}"},{"line":85,"address":[2403934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2304869,2304710,2305139,2306617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[2305268,2305105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[2305276,2305337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[2305345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2305600,2305497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2305662,2305733,2306030,2306097],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[2305669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2305788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[2306089,2306545,2305870],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":45},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","types.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Coin};\n\n// Minimum IBC timeout is 5 seconds\npub const MIN_IBC_TIMEOUT_SECONDS: u64 = 5;\n// Maximum IBC timeout is 1 hour\npub const MAX_IBC_TIMEOUT_SECONDS: u64 = 60 * 60;\n\npub const FEE_DENOM: \u0026str = \"untrn\";\n// Signer threshold can't be less than this value\npub const MIN_SIGNER_THRESHOLD: u8 = 2;\n// The reply ID for the instantiate_denom reply when linking a token\npub const INSTANTIATE_DENOM_REPLY_ID: u64 = 1;\n// The reply ID for IBC transfer to capture the channel and sequence\npub const IBC_REPLY_HANDLER_ID: u64 = 2;\n\n#[cw_serde]\npub struct Config {\n    /// The owner's address\n    pub owner: Addr,\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: String,\n    /// The channel used to communicate with the Hub\n    pub bridge_ibc_channel: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n#[cw_serde]\npub struct TokenMetadata {\n    /// The ticker of the CFT-20 token\n    pub ticker: String,\n    /// The name of the CFT-20 token\n    pub name: String,\n    /// The URL to the CFT-20 token's image\n    pub image_url: String,\n    /// The amount of decimals this CFT-20 uses\n    pub decimals: u32,\n}\n\n#[cw_serde]\npub struct QuerySignersResponse {\n    /// The signers currently loaded, the format is\n    /// (base64 public key, name)\n    pub signers: Vec\u003c(String, String)\u003e,\n}\n\n#[cw_serde]\npub struct QueryTokensResponse {\n    /// The list of token denoms allowed in bridging\n    pub tokens: Vec\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct BridgingAsset {\n    // pub channel_id: String,\n    // pub sequence: u64,\n    pub sender: Addr,\n    pub funds: Coin,\n}\n","traces":[{"line":10,"address":[44881159,44880699,44880962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[44880718,44881172],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","tests","integration.rs"],"content":"use asteroid_neutron_bridge::contract::instantiate;\nuse asteroid_neutron_bridge::error::ContractError;\nuse asteroid_neutron_bridge::execute::{execute, reply};\nuse asteroid_neutron_bridge::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse asteroid_neutron_bridge::query::query;\nuse asteroid_neutron_bridge::types::{\n    Config, QuerySignersResponse, QueryTokensResponse, TokenMetadata, MAX_IBC_TIMEOUT_SECONDS,\n    MIN_IBC_TIMEOUT_SECONDS,\n};\nuse astroport_test::cw_multi_test::{AppBuilder, Contract, ContractWrapper, Executor};\n// use astroport_test::modules::stargate::{MockStargate, StargateApp};\nuse cosmwasm_std::{Addr, Coin, Uint128};\nuse neutron_sdk::bindings::msg::NeutronMsg;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\nuse crate::stargate::{MockStargate, StargateApp};\n\ntype NeutronApp = StargateApp\u003cNeutronMsg, NeutronQuery\u003e;\n\nconst VALID_SIGNER_1: \u0026str = \"b577zulJVqWfXiip7ydZrvMgp2SzfR+IXhH7vkUjr+Y=\";\nconst VALID_SIGNER_2: \u0026str = \"vXRMhQtQNezXhdvYe1xlHYysGaEAJH2WwnV8Fvuuttw=\";\n\n// Signatures for TESTTOKEN with 6 decimals\nconst SIGNATURE_1: \u0026str =\n    \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\";\nconst SIGNATURE_2: \u0026str =\n    \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\";\n\n// Signatures for bridging 1000 TESTTOKEN\nconst BRIDGE_SIGNATURE_1: \u0026str =\n    \"ZwoqbZxvNaz06/0ZO+M7g0Ygf5YRKkWYNcm/yD+wYQ43N9/9i5xiSHxMhOo0wttNf5NP/T7Rrlv1Sp3K8qyiCw==\";\nconst BRIDGE_SIGNATURE_2: \u0026str =\n    \"+Y5UhcFimBzBnJX8BIFZPR2DjUp3DaYVRF81osV/qx8E4gDWk3z1EtUsLX3oITTld0lc12IQGdpuFcCWDAMVAQ==\";\n\nmod stargate;\n\nfn mock_app(owner: \u0026Addr, coins: Vec\u003cCoin\u003e) -\u003e NeutronApp {\n    AppBuilder::new_custom()\n        .with_stargate(MockStargate::default())\n        .build(|router, _, storage| {\n            // initialization moved to App construction\n            router.bank.init_balance(storage, owner, coins).unwrap()\n        })\n}\n\nfn bridge_contract() -\u003e Box\u003cdyn Contract\u003cNeutronMsg, NeutronQuery\u003e\u003e {\n    Box::new(ContractWrapper::new(execute, instantiate, query).with_reply(reply))\n}\n\n#[test]\nfn test_instantiate() {\n    let owner = Addr::unchecked(\"owner\");\n    let mut app = mock_app(\n        \u0026owner,\n        vec![Coin {\n            denom: \"untrn\".to_string(),\n            amount: Uint128::from(1000000u64),\n        }],\n    );\n    let contract_code = app.store_code(bridge_contract());\n\n    // Valid configuration\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Query to check all the values were set\n    let response: Config = app\n        .wrap()\n        .query_wasm_smart(bridge_address, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(response.bridge_chain_id, \"localgaia-1\");\n    assert_eq!(response.bridge_ibc_channel, \"channel-1\");\n    assert_eq!(response.ibc_timeout_seconds, 10);\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: MIN_IBC_TIMEOUT_SECONDS - 1,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MIN_IBC_TIMEOUT_SECONDS - 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: MAX_IBC_TIMEOUT_SECONDS + 1,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MAX_IBC_TIMEOUT_SECONDS + 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string()\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The source chain ID must be specified\".to_string()\n        }\n    );\n}\n\n#[test]\nfn test_add_signer() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add invalid signers\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"signer\".to_string(),\n                public_key_base64: \"invalid_key\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key could not be decoded\".to_string()\n        }\n    );\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a duplicate signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"duplicate-signer\".to_string(),\n                public_key_base64: VALID_SIGNER_1.to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The public key has already been loaded\".to_string()\n        }\n    );\n\n    // Attempt to add a signer without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"duplicate-signer\".to_string(),\n                public_key_base64: VALID_SIGNER_1.to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Query to check new signer was added\n    let response: QuerySignersResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Signers {})\n        .unwrap();\n\n    assert_eq!(response.signers.len(), 1);\n}\n\n#[test]\nfn test_remove_signer() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Remove an unknown signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"aW52YWxpZC1zaWduZXI=\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key to remove doesn't exist\".to_string()\n        }\n    );\n\n    // Remove an unknown signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"invalid_key\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key could not be decoded\".to_string()\n        }\n    );\n\n    // Attempt to remove a signer without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"aW52YWxpZC1zaWduZXI=\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Remove a known signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::RemoveSigner {\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure signer was removed\n    let response: QuerySignersResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Signers {})\n        .unwrap();\n\n    assert_eq!(response.signers.len(), 0);\n}\n\n#[test]\nfn test_update_config() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Attempt to update config without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt blank ibc channel\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: Some(\"\".to_string()),\n                ibc_timeout_seconds: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string()\n        }\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: Some(\"channel-9\".to_string()),\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt invalid IBC timeout\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: Some(MIN_IBC_TIMEOUT_SECONDS - 1),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MIN_IBC_TIMEOUT_SECONDS - 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: Some(MAX_IBC_TIMEOUT_SECONDS + 1),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MAX_IBC_TIMEOUT_SECONDS + 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: Some(MIN_IBC_TIMEOUT_SECONDS + 1),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check all the new values were set\n    let response: Config = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(response.bridge_chain_id, \"localgaia-1\");\n    assert_eq!(response.bridge_ibc_channel, \"channel-9\");\n    assert_eq!(response.ibc_timeout_seconds, MIN_IBC_TIMEOUT_SECONDS + 1);\n}\n\n#[test]\nfn test_link_token() {\n    let owner = Addr::unchecked(\"owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Signatures for TESTTOKEN with 6 decimals\n    let signature_1 =\n        \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\"\n            .to_string();\n    let signature_2 =\n        \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\"\n            .to_string();\n\n    // Duplicate signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone(), signature_1.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::DuplicateSignatures {}\n    );\n\n    // Invalid signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone(), signature_2.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Below threshold signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // No signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Valid signatures\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![signature_1.clone(), signature_2.clone()],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Attempt to add a duplicate\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1, signature_2],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenAlreadyExists {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n\n#[test]\nfn test_enable_disable_token() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Signatures for TESTTOKEN with 6 decimals\n    let signature_1 =\n        \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\"\n            .to_string();\n    let signature_2 =\n        \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\"\n            .to_string();\n\n    // Valid signatures\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![signature_1.clone(), signature_2.clone()],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Enable a token that wasn't disabled\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::EnableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"This token is not disabled\".to_string()\n        }\n    );\n\n    // Disable a token from wrong account\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::DisableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Disable invalid token\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::DisableToken {\n                ticker: \"NOT_TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDoesNotExist {\n            ticker: \"NOT_TESTTOKEN\".to_string()\n        }\n    );\n\n    // Disable token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check if it was disabled\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::DisabledTokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(response.tokens.len(), 1);\n\n    // Enable a token from wrong account\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::EnableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Enable token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::EnableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check if it was enabled\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::DisabledTokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(response.tokens.len(), 0);\n}\n\n#[test]\nfn test_bridge_receive() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Receive token not linked yet\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDoesNotExist {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n\n    // Valid signatures\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![\n                SIGNATURE_1.to_string().clone(),\n                SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Receive token with no signatures\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Receive token with invalid signature for the amount\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(10000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Receive zero tokens\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(0u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ZeroAmount {}\n    );\n\n    // Validate that the user has no TESTTOKEN balance\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    assert_eq!(res.len(), 0);\n\n    // Remove a signer to trigger a threshold too low\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::RemoveSigner {\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Bridge transaction with insufficient signatures\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Add the signer back\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Valid bridge transaction\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::Receive {\n            source_chain_id: \"localgaia-1\".to_string(),\n            transaction_hash: \"TXHASH1\".to_string(),\n            ticker: \"TESTTOKEN\".to_string(),\n            amount: Uint128::from(1000u64),\n            destination_addr: \"user1\".to_string(),\n            signatures: vec![\n                BRIDGE_SIGNATURE_1.to_string().clone(),\n                BRIDGE_SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Assert that the user received the testtoken\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    res.iter().for_each(|coin| {\n        if coin.denom == \"factory/contract0/TESTTOKEN\" {\n            assert_eq!(coin.amount, Uint128::from(1000u64));\n        }\n    });\n\n    // Replay the same transaction\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TransactionAlreadyHandled {\n            transaction_hash: \"TXHASH1\".to_string()\n        }\n    );\n\n    // Try invalid destination address\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidDestinationAddr {}\n    );\n\n    // Disable TESTTOKEN\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt to bridge a disabled token\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDisabled {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n\n// This test is partial, the rest is tested in a unit test to\n// verify IBC interactions\n#[test]\nfn test_bridge_send() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let user1 = Addr::unchecked(\"user1\");\n    let mut app = mock_app(\n        \u0026user1,\n        vec![\n            Coin {\n                denom: \"untrn\".to_string(),\n                amount: Uint128::from(1000000u64),\n            },\n            Coin {\n                denom: \"uatom\".to_string(),\n                amount: Uint128::from(1000000u64),\n            },\n        ],\n    );\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Link token\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![\n                SIGNATURE_1.to_string().clone(),\n                SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Valid bridge transaction\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::Receive {\n            source_chain_id: \"localgaia-1\".to_string(),\n            transaction_hash: \"TXHASH1\".to_string(),\n            ticker: \"TESTTOKEN\".to_string(),\n            amount: Uint128::from(1000u64),\n            destination_addr: \"user1\".to_string(),\n            signatures: vec![\n                BRIDGE_SIGNATURE_1.to_string().clone(),\n                BRIDGE_SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Assert that the user received the testtoken\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    res.iter().for_each(|coin| {\n        if coin.denom == \"factory/contract0/TESTTOKEN\" {\n            assert_eq!(coin.amount, Uint128::from(1000u64));\n        }\n    });\n\n    // Check the total supply of the token\n    let res = app\n        .wrap()\n        .query_supply(\"factory/contract0/TESTTOKEN\".to_string())\n        .unwrap();\n    assert_eq!(res.amount, Uint128::from(1000u64));\n\n    // Send incorrect tokens\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                // Coin {\n                //     denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                //     amount: Uint128::from(1u64),\n                // },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                // Coin {\n                //     denom: \"untrn\".to_string(),\n                //     amount: Uint128::from(1u64),\n                // },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"uatom\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    // Disable the token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Try bridging disabled token\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDisabled {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","tests","stargate.rs"],"content":"use cosmwasm_schema::serde::de::DeserializeOwned;\nuse cosmwasm_std::{\n    coins,\n    testing::{MockApi, MockStorage},\n    Addr, Api, BankMsg, Binary, BlockInfo, CustomMsg, CustomQuery, Empty, Querier, Storage,\n    SubMsgResponse,\n};\nuse cw_multi_test::{\n    App, AppResponse, BankKeeper, BankSudo, CosmosRouter, DistributionKeeper, FailingModule,\n    GovFailingModule, IbcFailingModule, Module, StakeKeeper, Stargate, StargateMsg, StargateQuery,\n    SudoMsg, WasmKeeper,\n};\n\nuse anyhow::{Ok, Result as AnyResult};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::{\n    MsgBurn, MsgCreateDenom, MsgCreateDenomResponse, MsgMint, MsgSetBeforeSendHook,\n    MsgSetDenomMetadata, MsgSetDenomMetadataResponse,\n};\n\npub type StargateApp\u003cExecC = Empty, QueryC = Empty\u003e = App\u003c\n    BankKeeper,\n    MockApi,\n    MockStorage,\n    FailingModule\u003cExecC, QueryC, Empty\u003e,\n    WasmKeeper\u003cExecC, QueryC\u003e,\n    StakeKeeper,\n    DistributionKeeper,\n    IbcFailingModule,\n    GovFailingModule,\n    MockStargate,\n\u003e;\n\n#[derive(Default)]\npub struct MockStargate {}\n\nimpl Stargate for MockStargate {}\n\nimpl Module for MockStargate {\n    type ExecT = StargateMsg;\n    type QueryT = StargateQuery;\n    type SudoT = Empty;\n\n    fn execute\u003cExecC, QueryC\u003e(\n        \u0026self,\n        api: \u0026dyn Api,\n        storage: \u0026mut dyn Storage,\n        router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        block: \u0026BlockInfo,\n        sender: Addr,\n        msg: Self::ExecT,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: CustomMsg + DeserializeOwned + 'static,\n        QueryC: CustomQuery + DeserializeOwned + 'static,\n    {\n        let StargateMsg {\n            type_url, value, ..\n        } = msg;\n\n        match type_url.as_str() {\n            MsgCreateDenom::TYPE_URL =\u003e {\n                let tf_msg: MsgCreateDenom = value.try_into()?;\n                let sender_address = tf_msg.sender.to_string();\n                let submsg_response = SubMsgResponse {\n                    events: vec![],\n                    data: Some(\n                        MsgCreateDenomResponse {\n                            new_token_denom: format!(\n                                \"factory/{}/{}\",\n                                sender_address, tf_msg.subdenom\n                            ),\n                        }\n                        .into(),\n                    ),\n                };\n                Ok(submsg_response.into())\n            }\n            MsgMint::TYPE_URL =\u003e {\n                let tf_msg: MsgMint = value.try_into()?;\n                let mint_coins = tf_msg\n                    .amount\n                    .expect(\"Empty amount in tokenfactory MsgMint!\");\n                #[cfg(not(any(feature = \"injective\", feature = \"sei\")))]\n                let to_address = tf_msg.mint_to_address.to_string();\n                #[cfg(any(feature = \"injective\", feature = \"sei\"))]\n                let to_address = sender.to_string();\n                let bank_sudo = BankSudo::Mint {\n                    to_address,\n                    amount: coins(mint_coins.amount.parse()?, mint_coins.denom),\n                };\n                router.sudo(api, storage, block, bank_sudo.into())\n            }\n            MsgBurn::TYPE_URL =\u003e {\n                let tf_msg: MsgBurn = value.try_into()?;\n                let burn_coins = tf_msg\n                    .amount\n                    .expect(\"Empty amount in tokenfactory MsgBurn!\");\n                let burn_msg = BankMsg::Burn {\n                    amount: coins(burn_coins.amount.parse()?, burn_coins.denom),\n                };\n                router.execute(\n                    api,\n                    storage,\n                    block,\n                    Addr::unchecked(sender),\n                    burn_msg.into(),\n                )\n            }\n            MsgSetBeforeSendHook::TYPE_URL =\u003e {\n                let before_hook_msg: MsgSetBeforeSendHook = value.try_into()?;\n                let msg = BankSudo::SetHook {\n                    contract_addr: before_hook_msg.cosmwasm_address,\n                    denom: before_hook_msg.denom,\n                };\n                router.sudo(api, storage, block, SudoMsg::Bank(msg))\n            }\n            MsgSetDenomMetadata::TYPE_URL =\u003e {\n                let _tf_msg: MsgSetDenomMetadata = value.try_into()?;\n                let submsg_response = SubMsgResponse {\n                    events: vec![],\n                    data: Some(MsgSetDenomMetadataResponse {}.into()),\n                };\n                Ok(submsg_response.into())\n            }\n            _ =\u003e Err(anyhow::anyhow!(\n                \"Unexpected exec msg {type_url} from {sender:?}\",\n            )),\n        }\n    }\n    fn query(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        _request: Self::QueryT,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        Ok(Binary::default())\n    }\n    fn sudo\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        _msg: Self::SudoT,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: CustomMsg + DeserializeOwned + 'static,\n        QueryC: CustomQuery + DeserializeOwned + 'static,\n    {\n        unimplemented!(\"Sudo not implemented\")\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse neutron_sdk::bindings::msg::NeutronMsg;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\nuse crate::error::ContractError;\nuse crate::msg::{InstantiateMsg, MigrateMsg};\nuse crate::state::CONFIG;\nuse crate::types::{Config, MAX_IBC_TIMEOUT_SECONDS, MIN_IBC_TIMEOUT_SECONDS};\n\n/// Contract name that is used for migration\nconst CONTRACT_NAME: \u0026str = \"asteroid-bridge\";\n/// Contract version that is used for migration\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the bridge contract, storing the config.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    // The bridge IBC channel must be specified, that is, the channel used\n    // to send information back to the source chain\n    if msg.bridge_ibc_channel.is_empty() {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string(),\n        });\n    }\n\n    // The source chain ID must be specified, that is, the chain ID of the\n    // source chain, not the chain ID where this contract is deployed\n    if msg.bridge_chain_id.is_empty() {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The source chain ID must be specified\".to_string(),\n        });\n    }\n\n    // Ensure valid IBC timeouts are set\n    if !(MIN_IBC_TIMEOUT_SECONDS..=MAX_IBC_TIMEOUT_SECONDS).contains(\u0026msg.ibc_timeout_seconds) {\n        return Err(ContractError::InvalidIBCTimeout {\n            timeout: msg.ibc_timeout_seconds,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        });\n    }\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        bridge_chain_id: msg.bridge_chain_id.clone(),\n        bridge_ibc_channel: msg.bridge_ibc_channel.clone(),\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\"bridge_chain_id\", msg.bridge_chain_id)\n        .add_attribute(\"bridge_ibc_channel\", msg.bridge_ibc_channel))\n}\n\n/// Migrates the contract to a new version, storing the new contract version.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_version = cw2::get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"asteroid-bridge\" =\u003e match contract_version.version.as_ref() {\n            \"1.0.1\" =\u003e {\n                let mut config = CONFIG.load(deps.storage)?;\n\n                // Allow changing the source chain ID in case the source chain\n                // undergoes an upgrade that changes the chain ID\n                if let Some(bridge_chain_id) = msg.bridge_chain_id {\n                    if bridge_chain_id.is_empty() {\n                        return Err(ContractError::InvalidConfiguration {\n                            reason: \"The source chain ID must be specified\".to_string(),\n                        });\n                    }\n                    config.bridge_chain_id = bridge_chain_id;\n                }\n\n                CONFIG.save(deps.storage, \u0026config)?;\n            }\n            _ =\u003e return Err(ContractError::MigrationError {}),\n        },\n        _ =\u003e return Err(ContractError::MigrationError {}),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n","traces":[{"line":20,"address":[11464606,11464282,11462416],"length":1,"stats":{"Line":12},"fn_name":"instantiate"},{"line":26,"address":[11462585,11462656,11464501,11462456],"length":1,"stats":{"Line":24},"fn_name":null},{"line":30,"address":[11462636,11462750],"length":1,"stats":{"Line":24},"fn_name":null},{"line":31,"address":[11464403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[11462776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[11462810,11462761],"length":1,"stats":{"Line":24},"fn_name":null},{"line":39,"address":[2320040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2318631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2318609,2318665],"length":1,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[2318730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2318726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2319000,2320033,2318681,2318832],"length":1,"stats":{"Line":23},"fn_name":null},{"line":55,"address":[2318969],"length":1,"stats":{"Line":12},"fn_name":null},{"line":56,"address":[2319138],"length":1,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[2319212],"length":1,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[2319469,2319320,2319397],"length":1,"stats":{"Line":24},"fn_name":null},{"line":61,"address":[2319643,2319457,2319558,2319723],"length":1,"stats":{"Line":48},"fn_name":null},{"line":63,"address":[2319611],"length":1,"stats":{"Line":12},"fn_name":null},{"line":64,"address":[2319691],"length":1,"stats":{"Line":12},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError, Uint128, VerificationError};\nuse ed25519_dalek::SignatureError;\nuse thiserror::Error;\n\n/// This enum describes bribes contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"The CFT-20 token '{ticker}' is already linked\")]\n    TokenAlreadyExists { ticker: String },\n\n    #[error(\"The CFT-20 token '{ticker}' has not been linked for bridging\")]\n    TokenDoesNotExist { ticker: String },\n\n    #[error(\"Insufficient valid signatures to confirm the message\")]\n    ThresholdNotMet {},\n\n    #[error(\"Duplicated signatures are not allowed\")]\n    DuplicateSignatures {},\n\n    #[error(\"This token has been disabled from bridging: {ticker}\")]\n    TokenDisabled { ticker: String },\n\n    #[error(\"The transaction has already been handled: {transaction_hash}\")]\n    TransactionAlreadyHandled { transaction_hash: String },\n\n    #[error(\"You can not send 0 CFT-20 tokens\")]\n    ZeroAmount {},\n\n    #[error(\"Invalid destination address\")]\n    InvalidDestinationAddr {},\n\n    #[error(\"Invalid IBC timeout: {timeout}, must be between {min} and {max} seconds\")]\n    InvalidIBCTimeout { timeout: u64, min: u64, max: u64 },\n\n    #[error(\"Invalid contract configuration: {reason}\")]\n    InvalidConfiguration { reason: String },\n\n    #[error(\"Invalid reply ID: {id}\")]\n    InvalidReplyId { id: u64 },\n\n    #[error(\"Invalid funds, expected NTRN and bridging token to be sent together and cover bridging cost\")]\n    InvalidFunds {},\n\n    #[error(\"Insufficient funds to cover the bridging cost, expected at least {expected} untrn\")]\n    InsufficientFunds { expected: Uint128 },\n\n    #[error(\"Failed to handle IBC transfer response: {detail}\")]\n    IBCResponseFail { detail: String },\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n\nimpl From\u003cVerificationError\u003e for ContractError {\n    fn from(v: VerificationError) -\u003e Self {\n        StdError::from(v).into()\n    }\n}\n\nimpl From\u003cSignatureError\u003e for ContractError {\n    fn from(v: SignatureError) -\u003e Self {\n        let std_error = StdError::generic_err(format!(\"Signature decode error: {}\", v));\n\n        // Utilize the existing conversion from StdError to ContractError\n        ContractError::from(std_error)\n    }\n}\n\nimpl From\u003cbase64::DecodeError\u003e for ContractError {\n    fn from(error: base64::DecodeError) -\u003e Self {\n        // Convert the base64::DecodeError to a generic StdError\n        let std_error = StdError::generic_err(format!(\"Base64 decode error: {}\", error));\n\n        // Utilize the existing conversion from StdError to ContractError\n        ContractError::from(std_error)\n    }\n}\n","traces":[{"line":60,"address":[48220002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2459072],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":62,"address":[46736688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[43821737,43821326,43821955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2459136],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":68,"address":[2459157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[44085150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2459200,2459572],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":74,"address":[2459349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[44085386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2459481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[46737269,46737160,46736880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[47959369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[44085473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2459672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[44085504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2459792],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","execute.rs"],"content":"use astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{coin, entry_point, Coin, Reply, StdError, SubMsg, Uint128};\nuse cosmwasm_std::{DepsMut, Env, MessageInfo, Response};\nuse ed25519_dalek::{VerifyingKey, PUBLIC_KEY_LENGTH};\n\nuse neutron_sdk::bindings::msg::{IbcFee, MsgIbcTransferResponse, NeutronMsg};\nuse neutron_sdk::bindings::query::NeutronQuery;\nuse neutron_sdk::query::min_ibc_fee::query_min_ibc_fee;\nuse neutron_sdk::sudo::msg::RequestPacketTimeoutHeight;\nuse osmosis_std::types::cosmos::bank::v1beta1::{DenomUnit, Metadata};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::{\n    MsgBurn, MsgCreateDenom, MsgCreateDenomResponse, MsgSetDenomMetadata,\n};\n\nuse crate::helpers::{build_mint_messages, verify_signatures};\nuse crate::msg::ExecuteMsg;\nuse crate::state::{\n    BRIDGE_CURRENT_PAYLOAD, BRIDGE_INFLIGHT, DISABLED_TOKENS, HANDLED_TRANSACTIONS,\n    OWNERSHIP_PROPOSAL, SIGNERS, TOKEN_MAPPING, TOKEN_METADATA,\n};\nuse crate::types::{\n    BridgingAsset, Config, TokenMetadata, FEE_DENOM, IBC_REPLY_HANDLER_ID,\n    INSTANTIATE_DENOM_REPLY_ID, MAX_IBC_TIMEOUT_SECONDS, MIN_IBC_TIMEOUT_SECONDS,\n};\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Exposes all the execute functions available in the contract\n///\n/// ## Executable Messages\n/// * **ExecuteMsg::LinkToken { source_chain_id, token,signatures } ** Link and enable a CFT-20 token to be bridged\n/// * **ExecuteMsg::EnableToken { ticker}** Enable a previously disabled token to being bridged again\n/// * **ExecuteMsg::DisableToken { ticker }** Disable a token from being bridged\n/// * **ExecuteMsg::Receive { source_chain_id, transaction_hash, ticker, amount, destination_addr, signatures }** Receive CFT-20 token message from the Hub\n/// * **ExecuteMsg::Send { destination_addr }** Send CFT-20 token back to the Hub\n/// * **ExecuteMsg::AddSigner { public_key_base64, name }** Adds a signer to the allowed list for signature verification\n/// * **ExecuteMsg::RemoveSigner { public_key_base64 }** Remove a signer from the allowed list for signature verification\n/// * **ExecuteMsg::UpdateConfig { ibc_timeout_seconds }** Update the contract config\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Propose a new owner for the contract\n/// * **ExecuteMsg::DropOwnershipProposal {}** Remove the ownership transfer proposal\n/// * **ExecuteMsg::ClaimOwnership {}** Claim contract ownership\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    match msg {\n        ExecuteMsg::LinkToken {\n            source_chain_id,\n            token,\n            signatures,\n        } =\u003e link_token(deps, env, source_chain_id, token, signatures),\n        ExecuteMsg::EnableToken { ticker } =\u003e enable_token(deps, env, info, ticker),\n        ExecuteMsg::DisableToken { ticker } =\u003e disable_token(deps, env, info, ticker),\n        ExecuteMsg::Receive {\n            source_chain_id,\n            transaction_hash,\n            ticker,\n            amount,\n            destination_addr,\n            signatures,\n        } =\u003e bridge_receive(\n            deps,\n            env,\n            source_chain_id,\n            transaction_hash,\n            ticker,\n            amount,\n            destination_addr,\n            signatures,\n        ),\n        ExecuteMsg::Send { destination_addr } =\u003e bridge_send(deps, env, info, destination_addr),\n        ExecuteMsg::AddSigner {\n            public_key_base64,\n            name,\n        } =\u003e add_signer(deps, info, name, public_key_base64),\n        ExecuteMsg::RemoveSigner { public_key_base64 } =\u003e {\n            remove_signer(deps, env, info, public_key_base64)\n        }\n        ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel,\n            ibc_timeout_seconds,\n        } =\u003e update_config(deps, info, bridge_ibc_channel, ibc_timeout_seconds),\n        ExecuteMsg::ProposeNewOwner { owner, expires_in } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// The entry point to the contract for processing replies from submessages.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    msg: Reply,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    match msg.id {\n        INSTANTIATE_DENOM_REPLY_ID =\u003e {\n            let MsgCreateDenomResponse { new_token_denom } = msg.result.try_into()?;\n\n            let metadata = TOKEN_METADATA.load(deps.storage)?;\n\n            let denom_metadata_msg = MsgSetDenomMetadata {\n                sender: env.contract.address.to_string(),\n                metadata: Some(Metadata {\n                    symbol: metadata.ticker.clone(),\n                    name: metadata.name,\n                    base: new_token_denom.clone(),\n                    display: metadata.ticker.clone(),\n                    denom_units: vec![\n                        DenomUnit {\n                            denom: new_token_denom.clone(),\n                            exponent: 0,\n                            aliases: vec![],\n                        },\n                        DenomUnit {\n                            denom: metadata.ticker.clone(),\n                            exponent: metadata.decimals,\n                            aliases: vec![],\n                        },\n                    ],\n                    description: format!(\n                        \"{} is an Asteroid CFT-20 token bridged from the Cosmos Hub\",\n                        metadata.ticker\n                    ),\n                    uri: metadata.image_url,\n                    uri_hash: \"\".to_string(),\n                }),\n            };\n\n            // Save the mapping of TICKER \u003c\u003e DENOM both ways to ease lookups\n            // in both directions\n            TOKEN_MAPPING.save(deps.storage, \u0026metadata.ticker, \u0026new_token_denom)?;\n            TOKEN_MAPPING.save(deps.storage, \u0026new_token_denom, \u0026metadata.ticker)?;\n            TOKEN_METADATA.remove(deps.storage);\n\n            Ok(Response::new()\n                .add_message(denom_metadata_msg)\n                .add_attribute(\"action\", \"set_denom_metadata\")\n                .add_attribute(\"ticker\", metadata.ticker))\n        }\n        IBC_REPLY_HANDLER_ID =\u003e {\n            // Extract the channel and sequence ID from the IBC transfer\n            let resp: MsgIbcTransferResponse = serde_json_wasm::from_slice(\n                msg.result\n                    .into_result()\n                    .map_err(StdError::generic_err)?\n                    .data\n                    .ok_or_else(|| StdError::generic_err(\"no result\"))?\n                    .as_slice(),\n            )\n            .map_err(|e| StdError::generic_err(format!(\"failed to parse response: {:?}\", e)))?;\n            let sequence_id = resp.sequence_id;\n            let channel_id = resp.channel;\n\n            // In order to handle the success/failure sudo call for IBC transfers\n            // we need to capture the CFT-20 assets being bridged back\n            // If it fails, the tokens need to be minted and returned again\n            let payload = BRIDGE_CURRENT_PAYLOAD.load(deps.storage)?;\n            BRIDGE_INFLIGHT.save(deps.storage, (\u0026channel_id.clone(), sequence_id), \u0026payload)?;\n            BRIDGE_CURRENT_PAYLOAD.remove(deps.storage);\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"capture_ibc_transfer\")\n                .add_attribute(\"channel\", channel_id)\n                .add_attribute(\"sequence\", sequence_id.to_string()))\n        }\n        _ =\u003e Err(ContractError::InvalidReplyId { id: msg.id }),\n    }\n}\n\n/// Enable the bridging of a CFT-20 token\n///\n/// If this token doesn't have a corresponding TokenFactory token one will\n/// be created using the information provided.\nfn link_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    source_chain_id: String,\n    token: TokenMetadata,\n    signatures: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // If we already have this token, return an error\n    if TOKEN_MAPPING.has(deps.storage, \u0026token.ticker) {\n        return Err(ContractError::TokenAlreadyExists {\n            ticker: token.ticker,\n        });\n    }\n\n    // Build the attestation message to verify the token information\n    // The format is {source_chain_id}{ticker}{decimals}{chain_id}{contract_address}\n    // cosmoshub-4ticker8neutron-1neutron1xxxxx\n    let attestation = format!(\n        \"{}{}{}{}{}\",\n        source_chain_id, token.ticker, token.decimals, env.block.chain_id, env.contract.address\n    );\n\n    // Verify with current keys\n    verify_signatures(deps.as_ref(), attestation.as_bytes(), \u0026signatures)?;\n\n    // If not, create the denom and set the metadata\n    let create_denom_msg = SubMsg::reply_on_success(\n        MsgCreateDenom {\n            sender: env.contract.address.to_string(),\n            subdenom: token.ticker.clone(),\n        },\n        INSTANTIATE_DENOM_REPLY_ID,\n    );\n\n    TOKEN_METADATA.save(deps.storage, \u0026token)?;\n\n    Ok(Response::new().add_submessage(create_denom_msg))\n}\n\n/// Enable a token for bridging if it was previously disabled\nfn enable_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    ticker: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // If this token isn't in the disabled list, return an error\n    if !DISABLED_TOKENS.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"This token is not disabled\".to_string(),\n        });\n    }\n\n    DISABLED_TOKENS.remove(deps.storage, \u0026ticker);\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"enable_token\")\n        .add_attribute(\"ticker\", ticker))\n}\n\n/// Disable a token for bridging\nfn disable_token(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    ticker: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // If this token doesn't exist, return an error\n    if !TOKEN_MAPPING.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDoesNotExist { ticker });\n    }\n\n    DISABLED_TOKENS.save(deps.storage, \u0026ticker, \u0026true)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"disable_token\")\n        .add_attribute(\"ticker\", ticker))\n}\n\n/// Receive tokens from the Hub and mint them to the destination address\nfn bridge_receive(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    source_chain_id: String,\n    transaction_hash: String,\n    ticker: String,\n    amount: Uint128,\n    destination_addr: String,\n    signatures: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // Check if the token is disabled\n    if DISABLED_TOKENS.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDisabled { ticker });\n    }\n    // Check the amount sent, if 0, reject\n    if amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n    // Check destination address, if invalid, reject\n    if deps.api.addr_validate(\u0026destination_addr).is_err() {\n        return Err(ContractError::InvalidDestinationAddr {});\n    }\n    // Check the ticker, if it doesn't exist activate needs to be called first\n    if !TOKEN_MAPPING.has(deps.storage, \u0026ticker) {\n        return Err(ContractError::TokenDoesNotExist { ticker });\n    }\n    // Check if we've processed this transaction already\n    if HANDLED_TRANSACTIONS.has(deps.storage, \u0026transaction_hash) {\n        return Err(ContractError::TransactionAlreadyHandled { transaction_hash });\n    }\n    // Store the transaction hash to prevent replay attacks\n    HANDLED_TRANSACTIONS.save(deps.storage, \u0026transaction_hash, \u0026true)?;\n\n    // Build the attestation message\n    let attestation = format!(\n        // source_chain_id, transaction_hash, ticker, amount\n        \"{}{}{}{}{}{}{}\",\n        source_chain_id,\n        transaction_hash,\n        ticker,\n        amount,\n        env.block.chain_id,\n        env.contract.address,\n        destination_addr\n    );\n\n    verify_signatures(deps.as_ref(), attestation.as_bytes(), \u0026signatures)?;\n\n    let tokenfactory_denom = TOKEN_MAPPING.load(deps.storage, \u0026ticker)?;\n\n    // If ticker already exists, mint new tokens to the destination\n    let coins_to_mint = coin(amount.u128(), tokenfactory_denom);\n\n    let mint_messages = build_mint_messages(\n        env.contract.address.to_string(),\n        coins_to_mint.clone(),\n        destination_addr.clone(),\n    );\n\n    Ok(Response::default()\n        .add_messages(mint_messages)\n        .add_attribute(\"action\", \"bridge_receive\")\n        .add_attribute(\"tokens\", coins_to_mint.to_string())\n        .add_attribute(\"destination\", destination_addr))\n}\n\n/// Return tokens to the Hub\nfn bridge_send(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    info: MessageInfo,\n    destination_addr: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // The user should be sending 2 tokens, one TokenFactory token to bridge back\n    // and NTRN for paying the IBC fees\n    let mut fee_coin = Coin::default();\n    let mut bridging_coin = Coin::default();\n\n    // Only the bridged token and NTRN must be sent\n    if info.funds.len() != 2 {\n        return Err(ContractError::InvalidFunds {});\n    }\n\n    info.funds.iter().for_each(|coin| {\n        if coin.denom == FEE_DENOM {\n            fee_coin = coin.clone();\n        }\n        if TOKEN_MAPPING.has(deps.storage, \u0026coin.denom) {\n            bridging_coin = coin.clone();\n        }\n    });\n\n    // If either of the coins is 0, reject\n    if fee_coin.amount.is_zero() || bridging_coin.amount.is_zero() {\n        return Err(ContractError::InvalidFunds {});\n    }\n\n    deps.api.debug(\u0026format!(\n        \"funds sent: {:?}\",\n        info.funds.iter().collect::\u003cVec\u003c_\u003e\u003e()\n    ));\n\n    // Check the mapping for this token, fail if no mapping exists\n    let cft20_denom = TOKEN_MAPPING.load(deps.storage, \u0026bridging_coin.denom)?;\n\n    // Check if the token is disabled\n    // We check the CFT-20 ticker and the TokenFactory in case one is missed in the disable\n    if DISABLED_TOKENS.has(deps.storage, \u0026cft20_denom)\n        || DISABLED_TOKENS.has(deps.storage, \u0026bridging_coin.denom)\n    {\n        return Err(ContractError::TokenDisabled {\n            ticker: cft20_denom,\n        });\n    }\n\n    // Contruct the IBC memo message to return X of denom on the Hub\n    // urn:bridge:gaialocal-1@v1;recv$tic=LOCALROIDS,amt=1,dst=cosmos1234,rch=neutronlocal-1,src=neutron1m857lgtjssgt0wm3crzfmt3v950vqnkqy4vep9\n    let memo = format!(\n        \"urn:bridge:{}@v1;recv$tic={},amt={},dst={},rch={},src={}\",\n        config.bridge_chain_id,\n        cft20_denom,\n        bridging_coin.amount,\n        destination_addr,\n        env.block.chain_id,\n        info.sender\n    );\n\n    // Burn the bridging token\n    let burn_msg = MsgBurn {\n        sender: env.contract.address.to_string(),\n        burn_from_address: env.contract.address.to_string(),\n        amount: Some(bridging_coin.clone().into()),\n    };\n\n    let fee = min_ntrn_ibc_fee(\n        query_min_ibc_fee(deps.as_ref())\n            .map_err(|err| StdError::generic_err(err.to_string()))?\n            .min_fee,\n    );\n\n    // Calculate the total fee required\n    let total_fee = fee\n        .ack_fee\n        .iter()\n        .chain(fee.recv_fee.iter())\n        .chain(fee.timeout_fee.iter())\n        .filter(|a| a.denom == FEE_DENOM)\n        .fold(Uint128::zero(), |acc, coin| acc + coin.amount);\n\n    // Ensure the user sent enough to cover the fee + 1 untrn to do the actual IBC transaction\n    let ibc_coin = coin(1u128, \"untrn\");\n    if total_fee \u003e fee_coin.amount.saturating_sub(Uint128::one()) {\n        return Err(ContractError::InsufficientFunds {\n            expected: total_fee.saturating_add(Uint128::one()),\n        });\n    }\n\n    // Construct the IBC transfer message\n    // The memo is important and enables the indexer to release the tokens on\n    // the Hub's side\n    let ibc_transfer = NeutronMsg::IbcTransfer {\n        source_port: \"transfer\".to_string(),\n        source_channel: config.bridge_ibc_channel,\n        // TODO: Note to auditor, please also confirm that this sender address can't be spoofed on the Hub's side\n        sender: env.contract.address.to_string(),\n        receiver: destination_addr.clone(),\n        token: ibc_coin,\n        timeout_height: RequestPacketTimeoutHeight {\n            revision_number: None,\n            revision_height: None,\n        },\n        // Neutron expects nanoseconds\n        // https://github.com/neutron-org/neutron/blob/303d764b57d871749fcf7d59a67b5d3078779258/proto/transfer/v1/tx.proto#L39-L42\n        timeout_timestamp: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .nanos(),\n        memo: memo.clone(),\n        fee,\n    };\n\n    // Capture the inflight asset to track the bridging to be able to handle the\n    // IBC failures\n    let inflight = BridgingAsset {\n        sender: info.sender,\n        funds: bridging_coin.clone(),\n    };\n    BRIDGE_CURRENT_PAYLOAD.save(deps.storage, \u0026inflight)?;\n\n    // Set up the submessage to capture the channel and sequence for the IBC transfer\n    let ibc_transfer_submessage = SubMsg::reply_on_success(ibc_transfer, IBC_REPLY_HANDLER_ID);\n\n    let response = Response::new()\n        .add_message(burn_msg)\n        .add_submessage(ibc_transfer_submessage)\n        .add_attribute(\"action\", \"bridge_send\")\n        .add_attribute(\"tokens\", bridging_coin.to_string())\n        .add_attribute(\"destination\", destination_addr);\n\n    Ok(response)\n}\n\n/// Add a signer to the list of allowed public keys\n/// Verifies that the public key can be loaded and in the correct format\n/// as well as checks for duplicate keys\nfn add_signer(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    info: MessageInfo,\n    name: String,\n    public_key_base64: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Decode the base64 encoded public key\n    let public_key = match general_purpose::STANDARD.decode(public_key_base64.as_bytes()) {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Key could not be decoded\".to_string(),\n            })\n        }\n    };\n\n    // Verify that the format for the key is correct before adding it\n    let public_key_bytes: [u8; PUBLIC_KEY_LENGTH] = match public_key.clone().try_into() {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Invalid public key length\".to_string(),\n            });\n        }\n    };\n    VerifyingKey::from_bytes(\u0026public_key_bytes)?;\n\n    // Ensure this key isn't loaded yet\n    if SIGNERS.has(deps.storage, \u0026public_key) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"The public key has already been loaded\".to_string(),\n        });\n    }\n\n    SIGNERS.save(deps.storage, \u0026public_key, \u0026name)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"add_signer\")\n        .add_attribute(\"name\", name)\n        .add_attribute(\"public_key\", public_key_base64))\n}\n\n/// Remove a signer from the list of allowed public keys\nfn remove_signer(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    _env: Env,\n    info: MessageInfo,\n    public_key_base64: String,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Decode the base64 encoded public key\n    let public_key = match general_purpose::STANDARD.decode(public_key_base64.as_bytes()) {\n        Ok(bytes) =\u003e bytes,\n        Err(_) =\u003e {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"Key could not be decoded\".to_string(),\n            })\n        }\n    };\n\n    if !SIGNERS.has(deps.storage, \u0026public_key) {\n        return Err(ContractError::InvalidConfiguration {\n            reason: \"Key to remove doesn't exist\".to_string(),\n        });\n    }\n\n    SIGNERS.remove(deps.storage, \u0026public_key);\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"remove_signer\")\n        .add_attribute(\"public_key\", public_key_base64))\n}\n\n/// Update the Bridge config\nfn update_config(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    info: MessageInfo,\n    bridge_ibc_channel: Option\u003cString\u003e,\n    ibc_timeout_seconds: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Allow changing the IBC channel in case the original channel expires\n    // and can't be revived\n    if let Some(bridge_ibc_channel) = bridge_ibc_channel {\n        if bridge_ibc_channel.is_empty() {\n            return Err(ContractError::InvalidConfiguration {\n                reason: \"The bridge IBC channel must be specified\".to_string(),\n            });\n        }\n\n        config.bridge_ibc_channel = bridge_ibc_channel;\n    }\n\n    // Validate minimum and maximum IBC timeout\n    if let Some(ibc_timeout_seconds) = ibc_timeout_seconds {\n        if !(MIN_IBC_TIMEOUT_SECONDS..=MAX_IBC_TIMEOUT_SECONDS).contains(\u0026ibc_timeout_seconds) {\n            return Err(ContractError::InvalidIBCTimeout {\n                timeout: ibc_timeout_seconds,\n                min: MIN_IBC_TIMEOUT_SECONDS,\n                max: MAX_IBC_TIMEOUT_SECONDS,\n            });\n        }\n        config.ibc_timeout_seconds = ibc_timeout_seconds;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Helper function to query the Neutron chain for the current minimum IBC fees\nfn min_ntrn_ibc_fee(fee: IbcFee) -\u003e IbcFee {\n    IbcFee {\n        recv_fee: fee.recv_fee,\n        ack_fee: fee\n            .ack_fee\n            .into_iter()\n            .filter(|a| a.denom == FEE_DENOM)\n            .collect(),\n        timeout_fee: fee\n            .timeout_fee\n            .into_iter()\n            .filter(|a| a.denom == FEE_DENOM)\n            .collect(),\n    }\n}\n\n#[cfg(test)]\nmod testing {\n    use std::marker::PhantomData;\n\n    use cosmwasm_std::testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage};\n    use cosmwasm_std::{\n        coins, to_json_binary, ContractResult, CosmosMsg, OwnedDeps, SubMsg, SystemResult,\n    };\n    use neutron_sdk::query::min_ibc_fee::MinIbcFeeResponse;\n\n    use crate::contract::instantiate;\n    use crate::msg::InstantiateMsg;\n\n    use super::*;\n\n    pub const OWNER: \u0026str = \"owner\";\n    pub const NOT_OWNER: \u0026str = \"not_owner\";\n    pub const USER: \u0026str = \"cosmos_user\";\n\n    fn mock_neutron_dependencies(\n        balances: \u0026[(\u0026str, \u0026[Coin])],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003cNeutronQuery\u003e, NeutronQuery\u003e {\n        let neutron_custom_handler = |request: \u0026NeutronQuery| {\n            let contract_result: ContractResult\u003c_\u003e = match request {\n                NeutronQuery::MinIbcFee {} =\u003e to_json_binary(\u0026MinIbcFeeResponse {\n                    min_fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                })\n                .into(),\n                _ =\u003e unimplemented!(\"Unsupported query request: {:?}\", request),\n            };\n            SystemResult::Ok(contract_result)\n        };\n\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(balances).with_custom_handler(neutron_custom_handler),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    #[test]\n    fn test_bridge_send() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        TOKEN_MAPPING\n            .save(\n                deps.as_mut().storage,\n                \"TESTTOKEN\",\n                \u0026\"factory/contract0/TESTTOKEN\".to_string(),\n            )\n            .unwrap();\n\n        TOKEN_MAPPING\n            .save(\n                deps.as_mut().storage,\n                \"factory/contract0/TESTTOKEN\",\n                \u0026\"TESTTOKEN\".to_string(),\n            )\n            .unwrap();\n\n        // Test with correct funds\n        let info = mock_info(\n            NOT_OWNER,\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(100u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(200_001u64),\n                },\n            ],\n        );\n        let response =\n            bridge_send(deps.as_mut(), mock_env(), info.clone(), USER.to_owned()).unwrap();\n\n        // Verify the tokens are burned\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgBurn {\n                sender: env.contract.address.to_string(),\n                burn_from_address: env.contract.address.to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: \"100\".to_string(),\n                }),\n            }),\n        );\n\n        // Verify the memo sent is correct\n        assert_eq!(response.messages[1].msg,CosmosMsg::Custom(NeutronMsg::IbcTransfer {\n                    source_port: \"transfer\".to_string(),\n                    source_channel: \"channel-1\".to_string(),\n                    sender: env.contract.address.to_string(),\n                    receiver: USER.to_string(),\n                    token: coin(1, \"untrn\"),\n                    timeout_height: RequestPacketTimeoutHeight {\n                        revision_number: None,\n                        revision_height: None,\n                    },\n                    timeout_timestamp: env.block.time.plus_seconds(300).nanos(),\n                    memo: \"urn:bridge:localgaia-1@v1;recv$tic=TESTTOKEN,amt=100,dst=cosmos_user,rch=cosmos-testnet-14002,src=not_owner\".to_string(),\n                    fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                }))\n    }\n}\n","traces":[{"line":43,"address":[2601184,2604140,2605124],"length":1,"stats":{"Line":7},"fn_name":"execute"},{"line":49,"address":[2601221],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[2601433,2603300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[2603321,2601564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[2603323,2601757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2601995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2602097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2602265,2603327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2602453],"length":1,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[2602603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[2602627,2603331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2602791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2602863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2602956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2603389,2603887,2603005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2603617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[2603660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2603727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[2603767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2603042,2604656,2604303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2604799,2604521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2603089,2605052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2284304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2284271,2284556,2284368],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":115,"address":[2284482,2284398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2284508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2284593,2284592],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":127,"address":[2605168,2611832,2609128],"length":1,"stats":{"Line":4},"fn_name":"reply"},{"line":132,"address":[2605230],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[2605782,2605431,2605638,2609299],"length":1,"stats":{"Line":8},"fn_name":null},{"line":136,"address":[2606197,2609275,2605742,2605931],"length":1,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[2606163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[2607674],"length":1,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[2609031,2608175,2608048,2608321],"length":1,"stats":{"Line":8},"fn_name":null},{"line":169,"address":[2608271,2608555,2609010,2608430],"length":1,"stats":{"Line":8},"fn_name":null},{"line":170,"address":[2608526],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[2608652,2608818,2608723],"length":1,"stats":{"Line":12},"fn_name":null},{"line":173,"address":[2608659],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[2608778],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[2605505,2609317,2609606,2609895,2611777,2609675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2609542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2284620,2284608],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":187,"address":[2284656,2284750],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":188,"address":[2610360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2610376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2611672,2610723,2610510,2610424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2611619,2610860,2610668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2611184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2611308,2611494,2611427,2611213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[2611268,2611351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2611609,2611486,2611359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2605358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2577023,2576717,2574336],"length":1,"stats":{"Line":3},"fn_name":"link_token"},{"line":219,"address":[2574557,2574411],"length":1,"stats":{"Line":6},"fn_name":null},{"line":220,"address":[2574734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[2574691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[2575189,2574983,2575317,2575092],"length":1,"stats":{"Line":12},"fn_name":null},{"line":234,"address":[2575762,2575566,2576728,2575507],"length":1,"stats":{"Line":8},"fn_name":null},{"line":238,"address":[2575922],"length":1,"stats":{"Line":4},"fn_name":null},{"line":239,"address":[2575731],"length":1,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[2575859],"length":1,"stats":{"Line":4},"fn_name":null},{"line":245,"address":[2576183,2576038,2576108],"length":1,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[2576272,2576168],"length":1,"stats":{"Line":8},"fn_name":null},{"line":251,"address":[2578250,2577040,2578352],"length":1,"stats":{"Line":1},"fn_name":"enable_token"},{"line":257,"address":[2577179,2578261,2577415,2577077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[2577548,2577384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[2577603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2577673,2577564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[2578126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[2577744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[2577711,2577793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[2577906,2577815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[2577875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[2579895,2579777,2578368],"length":1,"stats":{"Line":1},"fn_name":"disable_token"},{"line":285,"address":[2579788,2578408,2578746,2578510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[2578715,2578879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[2578934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[2578895,2579004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[2579089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[2579357,2579042,2579748,2579250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[2579446,2579345,2579530],"length":1,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[2579499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[2585024,2579920,2584655],"length":1,"stats":{"Line":1},"fn_name":"bridge_receive"},{"line":316,"address":[2580051,2580261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[2580340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[2580295,2580491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[2580568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[2580653,2580513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[2580837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[2580922,2580783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[2581037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[2581213,2580972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[2581328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[2581263,2581680,2581504,2584798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[2582257,2582142,2582543],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[2584777,2583039,2582824,2582765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":353,"address":[2583334,2582997,2583148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[2583294,2583474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[2583612,2583545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[2583636,2583689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[2583697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[2584182,2584084,2583953,2583841],"length":1,"stats":{"Line":4},"fn_name":null},{"line":365,"address":[2583889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[2584008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[2584645,2584016,2584143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[2584151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[2592711,2585040,2593753],"length":1,"stats":{"Line":2},"fn_name":"bridge_send"},{"line":378,"address":[2585115,2585297,2585531,2593524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":382,"address":[2585513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[2585672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[2585800,2585728],"length":1,"stats":{"Line":4},"fn_name":null},{"line":387,"address":[2585853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[2283873,2283520],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":391,"address":[2283563,2283751],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[2283654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[2283589,2283871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":395,"address":[2283774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2586043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[2586223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[2586160,2586439,2586763],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[2586184,2586292],"length":1,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[2587107,2586798,2593232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[2587368,2587042,2587272,2587438],"length":1,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[2587314,2587410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[2587605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2587549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[2587849,2588079,2588361,2587457],"length":1,"stats":{"Line":4},"fn_name":null},{"line":436,"address":[2588559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[2588634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[2588778,2588714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[2589017,2589382,2593140,2588969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[2283888,2283911],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":448,"address":[2589415,2589507,2589878,2589684,2589801],"length":1,"stats":{"Line":5},"fn_name":null},{"line":451,"address":[2589566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[2589691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[2284030,2284016],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":454,"address":[2284064,2284114],"length":1,"stats":{"Line":3},"fn_name":"{closure#3}"},{"line":457,"address":[2589933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[2590088,2589970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[2592942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[2592905,2590203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[2590176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[2590257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[2590297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[2590372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[2590520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2590657,2590596,2590584],"length":1,"stats":{"Line":3},"fn_name":null},{"line":485,"address":[2590685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[2591149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[2591196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[2591412,2591540,2591335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[2591629,2591464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":500,"address":[2591645,2592121,2591821,2592023,2591892],"length":1,"stats":{"Line":5},"fn_name":null},{"line":501,"address":[2591693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[2591828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[2592082,2591955,2592730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":505,"address":[2592090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[2592172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[2596262,2595988,2593776],"length":1,"stats":{"Line":6},"fn_name":"add_signer"},{"line":519,"address":[2593822,2594179,2596124,2593940],"length":1,"stats":{"Line":12},"fn_name":null},{"line":522,"address":[2594145,2594312],"length":1,"stats":{"Line":12},"fn_name":null},{"line":523,"address":[2594348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[2594411,2594323],"length":1,"stats":{"Line":12},"fn_name":null},{"line":528,"address":[2594462],"length":1,"stats":{"Line":5},"fn_name":null},{"line":530,"address":[2596007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[2594553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[2594643,2594526],"length":1,"stats":{"Line":7},"fn_name":null},{"line":538,"address":[2594668],"length":1,"stats":{"Line":5},"fn_name":null},{"line":540,"address":[2595857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[2594747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[2595804,2594793,2594930],"length":1,"stats":{"Line":6},"fn_name":null},{"line":548,"address":[2594999,2594876],"length":1,"stats":{"Line":12},"fn_name":null},{"line":549,"address":[2595706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[2595081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[2595136,2595239,2595035,2595674],"length":1,"stats":{"Line":12},"fn_name":null},{"line":556,"address":[2595412,2595328,2595491,2595224],"length":1,"stats":{"Line":24},"fn_name":null},{"line":558,"address":[2595381],"length":1,"stats":{"Line":6},"fn_name":null},{"line":559,"address":[2595460],"length":1,"stats":{"Line":6},"fn_name":null},{"line":563,"address":[2596288,2598011,2597784],"length":1,"stats":{"Line":1},"fn_name":"remove_signer"},{"line":569,"address":[2596331,2597920,2596433,2596672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":572,"address":[2596638,2596805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[2596841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[2596904,2596816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[2596960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[2597803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[2597070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[2597024,2597164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":587,"address":[2597652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[2597242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":[2597291,2597197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":594,"address":[2597404,2597313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":596,"address":[2597373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[2600667,2598032,2599206],"length":1,"stats":{"Line":1},"fn_name":"update_config"},{"line":607,"address":[2600500,2598240,2598087,2598464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[2598436,2598594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[2598636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[2598605,2598691,2599034],"length":1,"stats":{"Line":3},"fn_name":null},{"line":617,"address":[2598738,2598832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":618,"address":[2599044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[2598894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[2598921,2598838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[2599222,2598754,2599568],"length":1,"stats":{"Line":3},"fn_name":null},{"line":628,"address":[2599269,2599342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":629,"address":[2599578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[2599407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":633,"address":[2599437,2599348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[2599280,2599730,2599834],"length":1,"stats":{"Line":3},"fn_name":null},{"line":638,"address":[2599743,2599812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":639,"address":[2599849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[2599841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[2599818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[2600464,2598077,2600003,2599774,2599931],"length":1,"stats":{"Line":3},"fn_name":null},{"line":650,"address":[2600092,2599991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[2600688,2601145,2601124],"length":1,"stats":{"Line":1},"fn_name":"min_ntrn_ibc_fee"},{"line":656,"address":[2600710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[2600743,2600842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[2600987,2600871],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":185,"coverable":217},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","helpers.rs"],"content":"use base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{BankMsg, Coin, CosmosMsg, Deps, Order};\nuse neutron_sdk::bindings::{msg::NeutronMsg, query::NeutronQuery};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::MsgMint;\n\nuse crate::{error::ContractError, state::SIGNERS, types::MIN_SIGNER_THRESHOLD};\n\n/// Verify the signatures against the current loaded public keys\n/// Once we reach the valid threshold, we return Ok\n/// If we don't have enough valid signatures, we return Err\npub fn verify_signatures(\n    deps: Deps\u003cNeutronQuery\u003e,\n    message: \u0026[u8],\n    signatures: \u0026[String],\n) -\u003e Result\u003c(), ContractError\u003e {\n    // If no signatures were sent, fail the verification\n    if signatures.is_empty() {\n        return Err(ContractError::ThresholdNotMet {});\n    }\n\n    // If duplicate signatures are sent, fail the verification\n    let mut unique_signatures = signatures.to_vec();\n    unique_signatures.sort();\n    unique_signatures.dedup();\n    if unique_signatures.len() != signatures.len() {\n        return Err(ContractError::DuplicateSignatures {});\n    }\n\n    // Calculate the threshold based on the number of signers\n    let keys = SIGNERS.keys(deps.storage, None, None, Order::Ascending);\n    let majority_threshold = get_majority_threshold(keys.count());\n\n    // If the number of unique signatures are less than the threshold, fail the verification\n    if unique_signatures.len() \u003c majority_threshold.into() {\n        return Err(ContractError::ThresholdNotMet {});\n    }\n\n    // Load the current allowed public keys\n    let allowed_keys = SIGNERS.keys(deps.storage, None, None, Order::Ascending);\n\n    let mut verified_signatures = 0;\n\n    // Decode signatures from base64\n    let decoded_signatures: Result\u003cVec\u003c_\u003e, _\u003e = unique_signatures\n        .iter()\n        .map(|sig| general_purpose::STANDARD.decode(sig))\n        .collect();\n    let decoded_signatures = decoded_signatures?;\n\n    // Verify the signatures against the loaded keys\n    // This requires iterating over the signatures and the loaded keys\n    // and thus we should not keep too many keys loaded\n    //\n    // While there is a possbility for this to be unbounded, the number of keys\n    // will be small. The decision to use this method vs\n    // sending keys with their signatures was made to simplify interactions\n    // with the contract\n    for loaded_key in allowed_keys {\n        let allowed_key = loaded_key?;\n\n        for signature in \u0026decoded_signatures {\n            let is_valid = deps.api.ed25519_verify(message, signature, \u0026allowed_key)?;\n            if is_valid {\n                verified_signatures += 1;\n                if verified_signatures \u003e= majority_threshold {\n                    return Ok(());\n                }\n                // We can move on to the next key and signatures\n                break;\n            }\n        }\n    }\n    // If we reach this point, we did not have enough valid signatures\n    Err(ContractError::ThresholdNotMet {})\n}\n\n/// Construct messages to mint and transfer TokenFactory tokens\n/// TokenFactory tokens must always be minted by the contract address\npub fn build_mint_messages(\n    contract_address: String,\n    coin: Coin,\n    destination: String,\n) -\u003e Vec\u003cCosmosMsg\u003cNeutronMsg\u003e\u003e {\n    // TokenFactory can only mint to the sender\n    let mint_msg = MsgMint {\n        sender: contract_address.clone(),\n        amount: Some(coin.clone().into()),\n        mint_to_address: contract_address,\n    };\n\n    // Once minted to self, transfer to destination\n    let mint_transfer = BankMsg::Send {\n        to_address: destination,\n        amount: vec![coin.clone()],\n    };\n\n    vec![mint_msg.into(), mint_transfer.into()]\n}\n\n/// Get the majority threshold for the current amount of signers\n/// If the amount if an even number, we return the threshold as half of the signers + 1\n/// If the amount is an odd number, we return the threshold as half of the signers rounded up\n/// to the nearest integer\n/// If the threshold is less than the minimum threshold, we return the minimum threshold\npub fn get_majority_threshold(signers_count: usize) -\u003e u8 {\n    let threshold = if signers_count % 2 == 0 {\n        (signers_count / 2) + 1\n    } else {\n        (signers_count + 1) / 2\n    };\n\n    // Ensure the threshold is not less than MIN_SIGNER_THRESHOLD\n    threshold\n        .try_into()\n        .unwrap_or(MIN_SIGNER_THRESHOLD)\n        .max(MIN_SIGNER_THRESHOLD)\n}\n\n#[cfg(test)]\nmod testing {\n    use super::*;\n\n    #[test]\n    fn test_threshold_calculation() {\n        // Test the threshold calculation\n        assert_eq!(get_majority_threshold(0), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(1), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(2), MIN_SIGNER_THRESHOLD);\n        assert_eq!(get_majority_threshold(3), 2);\n        assert_eq!(get_majority_threshold(4), 3);\n        assert_eq!(get_majority_threshold(5), 3);\n        assert_eq!(get_majority_threshold(6), 4);\n        assert_eq!(get_majority_threshold(7), 4);\n        assert_eq!(get_majority_threshold(8), 5);\n        assert_eq!(get_majority_threshold(9), 5);\n        assert_eq!(get_majority_threshold(10), 6);\n\n        assert_eq!(get_majority_threshold(50), 26);\n        assert_eq!(get_majority_threshold(51), 26);\n\n        assert_eq!(get_majority_threshold(99), 50);\n        assert_eq!(get_majority_threshold(100), 51);\n    }\n}\n","traces":[{"line":11,"address":[2740103,2740211,2737552],"length":1,"stats":{"Line":3},"fn_name":"verify_signatures"},{"line":16,"address":[34393152,34393219,34393264,34393296,34393079,34393001,34393040,34393232,34392976,34393200,34393120,34393267,34393321,34393240],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":17,"address":[2737669],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[34046656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[34392961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[34047326,34047413,34046688],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[34047150],"length":1,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[2737871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[2737878],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[2738036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[34047405,34047307,34046742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2737934,2738086],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[2738102],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[2738153],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[2738336],"length":1,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[2738234,2738386],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[2738410],"length":1,"stats":{"Line":28},"fn_name":null},{"line":43,"address":[35233501,35233015,35233437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2738510,2738418],"length":1,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[2334805,2334784],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":48,"address":[2740147,2738607,2738807],"length":1,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[34047440],"length":1,"stats":{"Line":16},"fn_name":null},{"line":51,"address":[34047473],"length":1,"stats":{"Line":8},"fn_name":null},{"line":52,"address":[34047491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[44166009,44166099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[34047520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[34047548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[34047562],"length":1,"stats":{"Line":18},"fn_name":null},{"line":58,"address":[2738755,2740096,2738905],"length":1,"stats":{"Line":19},"fn_name":null},{"line":59,"address":[2739235,2739364,2739085,2740114],"length":1,"stats":{"Line":16},"fn_name":null},{"line":61,"address":[2739324,2739507,2739619],"length":1,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[2739927,2739635,2740086],"length":1,"stats":{"Line":12},"fn_name":null},{"line":63,"address":[2739910],"length":1,"stats":{"Line":42},"fn_name":null},{"line":64,"address":[2739969,2740021],"length":1,"stats":{"Line":23},"fn_name":null},{"line":65,"address":[2740007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2740061],"length":1,"stats":{"Line":36},"fn_name":null},{"line":68,"address":[44166644],"length":1,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[35234703],"length":1,"stats":{"Line":7},"fn_name":null},{"line":74,"address":[2739120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[2741743,2740240,2741634],"length":1,"stats":{"Line":13},"fn_name":"build_mint_messages"},{"line":84,"address":[35234976],"length":1,"stats":{"Line":7},"fn_name":"encode_length"},{"line":86,"address":[2740320],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[2740457,2740393],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[2740705,2740771,2741684],"length":1,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[2741645,2741050,2741108],"length":1,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[2741776],"length":1,"stats":{"Line":5},"fn_name":"get_majority_threshold"},{"line":106,"address":[2741956,2741859,2741790],"length":1,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[2741854,2741861,2741805],"length":1,"stats":{"Line":10},"fn_name":null},{"line":109,"address":[2741947,2741832,2741958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[2741891],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":42,"coverable":50},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod helpers;\npub mod msg;\npub mod query;\npub mod state;\npub mod sudo;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","msg.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Uint128;\n\nuse crate::types::{Config, QuerySignersResponse, QueryTokensResponse, TokenMetadata};\n\n/// Holds the parameters used for creating a Hub contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: String,\n    /// The IBC channel to the Cosmos Hub\n    pub bridge_ibc_channel: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: Option\u003cString\u003e,\n}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Link and enable a CFT-20 token to be bridged\n    LinkToken {\n        /// The chain ID of the source chain\n        source_chain_id: String,\n        /// The metadata of the CFT-20 token\n        token: TokenMetadata,\n        /// The signatures of from the verifying parties\n        signatures: Vec\u003cString\u003e,\n    },\n    // Enable a previously disabled token to being bridged again\n    EnableToken {\n        /// The ticker of the CFT-20 token\n        ticker: String,\n    },\n    // Disable a token from being bridged\n    DisableToken {\n        /// The ticker of the CFT-20 token\n        ticker: String,\n    },\n    /// Receive CFT-20 token message from the Hub\n    Receive {\n        /// The chain ID of the source chain\n        source_chain_id: String,\n        /// The hash of the transaction on the origin chain\n        transaction_hash: String,\n        /// The ticker of the CFT-20 token\n        ticker: String,\n        /// The amount of CFT-20 tokens\n        amount: Uint128,\n        /// The destination address to transfer the CFT-20-equivalent to\n        destination_addr: String,\n        /// The signatures of from the verifying parties\n        signatures: Vec\u003cString\u003e,\n    },\n    /// Send CFT-20 token back to the Hub\n    Send {\n        /// The destination address to transfer the CFT-20-equivalent to\n        destination_addr: String,\n    },\n    /// Adds a signer to the allowed list for signature verification\n    AddSigner {\n        /// The public key in base64. This is the raw key without the ASN.1\n        /// structure, that is, the last 32 bytes from the DER-encoded public key\n        public_key_base64: String,\n        /// A simple human name for the owner of the public key\n        name: String,\n    },\n    /// Remove a signer from the allowed list for signature verification\n    RemoveSigner {\n        /// The public key in base64 to remove. This is the same key added using\n        /// AddSigner\n        public_key_base64: String,\n    },\n    /// Update the contract config\n    UpdateConfig {\n        /// The IBC channel to the Cosmos Hub\n        bridge_ibc_channel: Option\u003cString\u003e,\n        /// The timeout in seconds for IBC packets\n        ibc_timeout_seconds: Option\u003cu64\u003e,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner {\n        /// The owner being proposed\n        owner: String,\n        /// Time in seconds for the proposal to expire\n        expires_in: u64,\n    },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Bridge\n    #[returns(Config)]\n    Config {},\n    /// Returns the allowed signers for signature verification\n    #[returns(QuerySignersResponse)]\n    Signers {},\n    /// Returns all the tokens that have been added to the bridge\n    #[returns(QueryTokensResponse)]\n    Tokens {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Returns the disabled tokens\n    #[returns(QueryTokensResponse)]\n    DisabledTokens {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","query.rs"],"content":"use crate::state::{CONFIG, DISABLED_TOKENS, TOKEN_MAPPING};\nuse crate::types::{QuerySignersResponse, QueryTokensResponse};\nuse crate::{msg::QueryMsg, state::SIGNERS};\nuse base64::{engine::general_purpose, Engine as _};\nuse cosmwasm_std::{entry_point, to_json_binary, Binary, Deps, Env, Order, StdError, StdResult};\nuse cw_storage_plus::Bound;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\n// Settings for pagination.\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns the config of the Bridge\n/// * **QueryMsg::Signers {}** Returns the current signers and their public keys in base64\n/// * **QueryMsg::Tokens { start_after, limit }** Returns the CFT-20 and TokenFactory tokens that can be bridged\n/// * **QueryMsg::DisabledTokens { start_after, limit }** Returns the CFT-20 and TokenFactory tokens that have been disabled from bridging},\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps\u003cNeutronQuery\u003e, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_json_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Signers {} =\u003e {\n            let signers: Result\u003cVec\u003c_\u003e, StdError\u003e = SIGNERS\n                .range(deps.storage, None, None, Order::Ascending)\n                .map(|result| {\n                    result.map(|(key, value)| (general_purpose::STANDARD.encode(key), value))\n                })\n                .collect();\n\n            match signers {\n                Ok(signers) =\u003e to_json_binary(\u0026QuerySignersResponse { signers }),\n                Err(e) =\u003e Err(e),\n            }\n        }\n        QueryMsg::Tokens { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_all_tokens(deps, start_after, limit)?)\n        }\n        QueryMsg::DisabledTokens { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_disabled_tokens(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Queries all tokens that have been added to the bridge\npub fn query_all_tokens(\n    deps: Deps\u003cNeutronQuery\u003e,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cQueryTokensResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start_bound = start_after.as_deref().map(Bound::exclusive);\n\n    let tokens = TOKEN_MAPPING\n        .keys(deps.storage, start_bound, None, Order::Ascending)\n        .take(limit)\n        .map(|key_result| key_result.map_err(StdError::from))\n        .collect::\u003cStdResult\u003cVec\u003cString\u003e\u003e\u003e()?;\n\n    Ok(QueryTokensResponse { tokens })\n}\n\n/// Queries all disabled tokens\npub fn query_disabled_tokens(\n    deps: Deps\u003cNeutronQuery\u003e,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cQueryTokensResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start_bound = start_after.as_deref().map(Bound::exclusive);\n\n    let tokens = DISABLED_TOKENS\n        .keys(deps.storage, start_bound, None, Order::Ascending)\n        .take(limit)\n        .map(|key_result| key_result.map_err(StdError::from))\n        .collect::\u003cStdResult\u003cVec\u003cString\u003e\u003e\u003e()?;\n\n    Ok(QueryTokensResponse { tokens })\n}\n","traces":[{"line":21,"address":[2315777,2314016,2314886],"length":1,"stats":{"Line":1},"fn_name":"query"},{"line":22,"address":[2314048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2314084,2314519,2314897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[34055736,34056770,34058233,34058188,34058278,34055704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[34055757,34058253,34055719,34058208,34056785,34058284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[2314121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2438832],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":28,"address":[2438896,2438860,2438880],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":32,"address":[2314965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2314995,2315136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[2315074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[34055992,34058515,34058584,34055953,34058650,34057072],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[2314268,2315202,2315470],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[2314347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[34850678,34849653,34849610,34851599,34851542,34851656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2313231,2312512],"length":1,"stats":{"Line":3},"fn_name":"query_all_tokens"},{"line":52,"address":[2312576,2312646],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[2312681],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[2313183,2312781],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[2312725],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[2438764,2438736],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":61,"address":[34887035,34887575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[2313264,2313983],"length":1,"stats":{"Line":1},"fn_name":"query_disabled_tokens"},{"line":70,"address":[34891805,34890168,34891667,34890260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[2313433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2313533,2313935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2313477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[34617527,34617192,34617388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2438812,2438784],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":79,"address":[2313768],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":30},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse crate::types::{BridgingAsset, Config, TokenMetadata};\n\nuse astroport::common::OwnershipProposal;\n\n/// Store the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// The public keys of the allowed signers of bridge messages used to confirm\n/// signature. The public key is stored in the format required during bridging\n/// It holds \u003cpublic key, name\u003e to help identify specific keys\npub const SIGNERS: Map\u003c\u0026[u8], String\u003e = Map::new(\"signers\");\n\n// Token Mapping is kept in a map of\n// CFT-20 Ticker -\u003e TokenFactory denom as well as the reverse\n// TokenFactory denom -\u003e CFT-20 Ticker\npub const TOKEN_MAPPING: Map\u003c\u0026str, String\u003e = Map::new(\"token_mapping\");\n\n/// Store the disabled tokens\npub const DISABLED_TOKENS: Map\u003c\u0026str, bool\u003e = Map::new(\"disabled_tokens\");\n\n/// Store the transactions we've processed\npub const HANDLED_TRANSACTIONS: Map\u003c\u0026str, bool\u003e = Map::new(\"handled_transactions\");\n\n/// Store the token metadata when the denom is created via Reply\npub const TOKEN_METADATA: Item\u003cTokenMetadata\u003e = Item::new(\"token_metadata\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Holds the bridging assets that are currently in flight\npub const BRIDGE_INFLIGHT: Map\u003c(\u0026str, u64), BridgingAsset\u003e = Map::new(\"bridge_inflight\");\n\n/// Temporary storage for the payload of the current bridge message for handling replies\npub const BRIDGE_CURRENT_PAYLOAD: Item\u003cBridgingAsset\u003e = Item::new(\"bridge_current_payload\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","sudo.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, Response};\nuse neutron_sdk::{\n    bindings::{msg::NeutronMsg, query::NeutronQuery},\n    sudo::msg::TransferSudoMsg,\n};\n\nuse crate::{error::ContractError, helpers::build_mint_messages, state::BRIDGE_INFLIGHT};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn sudo(\n    deps: DepsMut\u003cNeutronQuery\u003e,\n    env: Env,\n    msg: TransferSudoMsg,\n) -\u003e Result\u003cResponse\u003cNeutronMsg\u003e, ContractError\u003e {\n    // Neutron requires sudo endpoint to be implemented to handle success and\n    // failures of the IBC transfers\n    // We use this to mint and return the funds to the sender in case of an error\n    // by storing the currently in-flight assets in the contract state\n    // based on channel and sequence id\n    match msg {\n        TransferSudoMsg::Response { request, .. } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in success\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in success\".to_string(),\n                })?;\n\n            // The IBC transfer succeeded, we can remove the bridging asset from the in-flight\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"success on sequence {:?}\", sequence_id)))\n        }\n        TransferSudoMsg::Error { request, .. } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in error\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in error\".to_string(),\n                })?;\n\n            // Get the assets being bridged for this channel and sequence\n            // We need to mint and return the funds to the sender\n            let payload = BRIDGE_INFLIGHT.load(deps.storage, (\u0026channel_id, sequence_id))?;\n\n            let mint_messages = build_mint_messages(\n                env.contract.address.to_string(),\n                payload.funds.clone(),\n                payload.sender.to_string(),\n            );\n\n            // Remove the in-flight asset as it has been handled\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_messages(mint_messages)\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"error on sequence {:?}\", sequence_id)))\n        }\n        TransferSudoMsg::Timeout { request } =\u003e {\n            let channel_id =\n                request\n                    .source_channel\n                    .ok_or_else(|| ContractError::IBCResponseFail {\n                        detail: \"missing channel id in timeout\".to_string(),\n                    })?;\n\n            let sequence_id = request\n                .sequence\n                .ok_or_else(|| ContractError::IBCResponseFail {\n                    detail: \"missing sequence id in timeout\".to_string(),\n                })?;\n\n            // Get the assets being bridged for this channel and sequence\n            // We need to mint and return the funds to the sender\n            let payload = BRIDGE_INFLIGHT.load(deps.storage, (\u0026channel_id, sequence_id))?;\n\n            let mint_messages = build_mint_messages(\n                env.contract.address.to_string(),\n                payload.funds.clone(),\n                payload.sender.to_string(),\n            );\n\n            // Remove the in-flight asset as it has been handled\n            BRIDGE_INFLIGHT.remove(deps.storage, (\u0026channel_id, sequence_id));\n\n            Ok(Response::new()\n                .add_messages(mint_messages)\n                .add_attribute(\"action\", \"ibc_bridge_response\")\n                .add_attribute(\"state\", format!(\"timeout on sequence {:?}\", sequence_id)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod testing {\n    use std::marker::PhantomData;\n\n    use cosmwasm_std::testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage};\n    use cosmwasm_std::{\n        coin, coins, to_json_binary, Addr, BankMsg, Coin, ContractResult, OwnedDeps, SubMsg,\n        SystemResult,\n    };\n    use neutron_sdk::bindings::msg::IbcFee;\n    use neutron_sdk::query::min_ibc_fee::MinIbcFeeResponse;\n    use neutron_sdk::sudo::msg::RequestPacket;\n    use osmosis_std::types::osmosis::tokenfactory::v1beta1::MsgMint;\n\n    use crate::contract::instantiate;\n    use crate::msg::InstantiateMsg;\n    use crate::sudo::sudo;\n    use crate::types::{BridgingAsset, FEE_DENOM};\n\n    use super::*;\n\n    pub const OWNER: \u0026str = \"owner\";\n    pub const USER: \u0026str = \"cosmos_user\";\n\n    fn mock_neutron_dependencies(\n        balances: \u0026[(\u0026str, \u0026[Coin])],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003cNeutronQuery\u003e, NeutronQuery\u003e {\n        let neutron_custom_handler = |request: \u0026NeutronQuery| {\n            let contract_result: ContractResult\u003c_\u003e = match request {\n                NeutronQuery::MinIbcFee {} =\u003e to_json_binary(\u0026MinIbcFeeResponse {\n                    min_fee: IbcFee {\n                        recv_fee: vec![],\n                        ack_fee: coins(100_000, FEE_DENOM),\n                        timeout_fee: coins(100_000, FEE_DENOM),\n                    },\n                })\n                .into(),\n                _ =\u003e unimplemented!(\"Unsupported query request: {:?}\", request),\n            };\n            SystemResult::Ok(contract_result)\n        };\n\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(balances).with_custom_handler(neutron_custom_handler),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    #[test]\n    fn test_bridge_sudo_success() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(100, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in success\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in success\".to_string()\n            }\n        );\n\n        sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Response {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                data: to_json_binary(\"\").unwrap(),\n            },\n        )\n        .unwrap();\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n\n    #[test]\n    fn test_bridge_sudo_error() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(100, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in error\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in error\".to_string()\n            }\n        );\n\n        let response = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Error {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n                details: \"\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Verify the tokens are minted\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgMint {\n                sender: \"cosmos2contract\".to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    amount: \"100\".to_string(),\n                    denom: \"factory/contract0/TESTTOKEN\".to_string()\n                }),\n                mint_to_address: \"cosmos2contract\".to_string()\n            }),\n        );\n\n        // And sent to the original sender\n        assert_eq!(\n            response.messages[1],\n            SubMsg::new(BankMsg::Send {\n                to_address: USER.to_string(),\n                amount: coins(100u128, \"factory/contract0/TESTTOKEN\".to_string())\n            })\n        );\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n\n    #[test]\n    fn test_bridge_sudo_timeout() {\n        let mut deps = mock_neutron_dependencies(\u0026[]);\n        let env = mock_env();\n\n        let info = mock_info(OWNER, \u0026[]);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            InstantiateMsg {\n                owner: OWNER.to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                ibc_timeout_seconds: 300,\n            },\n        )\n        .unwrap();\n\n        BRIDGE_INFLIGHT\n            .save(\n                \u0026mut deps.storage,\n                (\"channel-1\", 1),\n                \u0026BridgingAsset {\n                    sender: Addr::unchecked(USER),\n                    funds: coin(1000, \"factory/contract0/TESTTOKEN\"),\n                },\n            )\n            .unwrap();\n\n        // Invalid channel\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: None,\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing channel id in timeout\".to_string()\n            }\n        );\n\n        // Invalid sequence\n        let err = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: None,\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap_err();\n\n        assert_eq!(\n            err,\n            ContractError::IBCResponseFail {\n                detail: \"missing sequence id in timeout\".to_string()\n            }\n        );\n\n        let response = sudo(\n            deps.as_mut(),\n            env.clone(),\n            neutron_sdk::sudo::msg::TransferSudoMsg::Timeout {\n                request: RequestPacket {\n                    sequence: Some(1u64),\n                    source_port: Some(\"transfer\".to_string()),\n                    source_channel: Some(\"channel-1\".to_string()),\n                    destination_port: Some(\"transfer\".to_string()),\n                    destination_channel: Some(\"channel-1\".to_string()),\n                    timeout_height: None,\n                    timeout_timestamp: None,\n                    data: None,\n                },\n            },\n        )\n        .unwrap();\n\n        // Verify the tokens are minted\n        assert_eq!(\n            response.messages[0],\n            SubMsg::new(MsgMint {\n                sender: \"cosmos2contract\".to_string(),\n                amount: Some(osmosis_std::types::cosmos::base::v1beta1::Coin {\n                    amount: \"1000\".to_string(),\n                    denom: \"factory/contract0/TESTTOKEN\".to_string()\n                }),\n                mint_to_address: \"cosmos2contract\".to_string()\n            }),\n        );\n\n        // And sent to the original sender\n        assert_eq!(\n            response.messages[1],\n            SubMsg::new(BankMsg::Send {\n                to_address: USER.to_string(),\n                amount: coins(1000u128, \"factory/contract0/TESTTOKEN\".to_string())\n            })\n        );\n\n        // Check that the inflight was removed\n        assert!(!BRIDGE_INFLIGHT.has(\u0026deps.storage, (\"channel-1\", 1)));\n    }\n}\n","traces":[{"line":10,"address":[2301038,2306640,2299136],"length":1,"stats":{"Line":3},"fn_name":"sudo"},{"line":20,"address":[2299198],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[2299319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2299849,2299345,2301105,2299647],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[2399854,2399808],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[2399822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2299934,2300124,2299743],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[2399904,2399950],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":32,"address":[2399918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[2300181,2299998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2300554,2300621,2300243],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[2300298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2300387,2300613,2301057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2299411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2299437,2301463,2301665,2303667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[2400000,2400046],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":47,"address":[2400014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2301750,2301940,2301559,2303646],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2400096,2400142],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":53,"address":[2400110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[2302267,2301997,2301814,2303625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2302233,2302396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[2302465,2302404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2302473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2302625,2302728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[2302861,2303160,2303227,2302790],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[2302797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2302916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2303219,2303553,2302999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2299503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2303975,2304177,2299529,2306275],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[2400238,2400192],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":79,"address":[2400206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2304071,2304440,2306254,2304262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[2400288,2400334],"length":1,"stats":{"Line":2},"fn_name":"{closure#5}"},{"line":85,"address":[2400302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2304485,2304326,2304755,2306233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[2304884,2304721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[2304892,2304953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[2304961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2305216,2305113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2305646,2305713,2305349,2305278],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[2305285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2305404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[2305486,2305705,2306161],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":45},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","src","types.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Coin};\n\n// Minimum IBC timeout is 5 seconds\npub const MIN_IBC_TIMEOUT_SECONDS: u64 = 5;\n// Maximum IBC timeout is 1 hour\npub const MAX_IBC_TIMEOUT_SECONDS: u64 = 60 * 60;\n\npub const FEE_DENOM: \u0026str = \"untrn\";\n// Signer threshold can't be less than this value\npub const MIN_SIGNER_THRESHOLD: u8 = 2;\n// The reply ID for the instantiate_denom reply when linking a token\npub const INSTANTIATE_DENOM_REPLY_ID: u64 = 1;\n// The reply ID for IBC transfer to capture the channel and sequence\npub const IBC_REPLY_HANDLER_ID: u64 = 2;\n\n#[cw_serde]\npub struct Config {\n    /// The owner's address\n    pub owner: Addr,\n    /// The chain ID this bridge is connected to\n    pub bridge_chain_id: String,\n    /// The channel used to communicate with the Hub\n    pub bridge_ibc_channel: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n#[cw_serde]\npub struct TokenMetadata {\n    /// The ticker of the CFT-20 token\n    pub ticker: String,\n    /// The name of the CFT-20 token\n    pub name: String,\n    /// The URL to the CFT-20 token's image\n    pub image_url: String,\n    /// The amount of decimals this CFT-20 uses\n    pub decimals: u32,\n}\n\n#[cw_serde]\npub struct QuerySignersResponse {\n    /// The signers currently loaded, the format is\n    /// (base64 public key, name)\n    pub signers: Vec\u003c(String, String)\u003e,\n}\n\n#[cw_serde]\npub struct QueryTokensResponse {\n    /// The list of token denoms allowed in bridging\n    pub tokens: Vec\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct BridgingAsset {\n    // pub channel_id: String,\n    // pub sequence: u64,\n    pub sender: Addr,\n    pub funds: Coin,\n}\n","traces":[{"line":10,"address":[44876786,44876523,44876983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[44876996,44876542],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","tests","integration.rs"],"content":"use asteroid_neutron_bridge::contract::instantiate;\nuse asteroid_neutron_bridge::error::ContractError;\nuse asteroid_neutron_bridge::execute::{execute, reply};\nuse asteroid_neutron_bridge::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse asteroid_neutron_bridge::query::query;\nuse asteroid_neutron_bridge::types::{\n    Config, QuerySignersResponse, QueryTokensResponse, TokenMetadata, MAX_IBC_TIMEOUT_SECONDS,\n    MIN_IBC_TIMEOUT_SECONDS,\n};\nuse astroport_test::cw_multi_test::{AppBuilder, Contract, ContractWrapper, Executor};\n// use astroport_test::modules::stargate::{MockStargate, StargateApp};\nuse cosmwasm_std::{Addr, Coin, Uint128};\nuse neutron_sdk::bindings::msg::NeutronMsg;\nuse neutron_sdk::bindings::query::NeutronQuery;\n\nuse crate::stargate::{MockStargate, StargateApp};\n\ntype NeutronApp = StargateApp\u003cNeutronMsg, NeutronQuery\u003e;\n\nconst VALID_SIGNER_1: \u0026str = \"b577zulJVqWfXiip7ydZrvMgp2SzfR+IXhH7vkUjr+Y=\";\nconst VALID_SIGNER_2: \u0026str = \"vXRMhQtQNezXhdvYe1xlHYysGaEAJH2WwnV8Fvuuttw=\";\n\n// Signatures for TESTTOKEN with 6 decimals\nconst SIGNATURE_1: \u0026str =\n    \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\";\nconst SIGNATURE_2: \u0026str =\n    \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\";\n\n// Signatures for bridging 1000 TESTTOKEN\nconst BRIDGE_SIGNATURE_1: \u0026str =\n    \"ZwoqbZxvNaz06/0ZO+M7g0Ygf5YRKkWYNcm/yD+wYQ43N9/9i5xiSHxMhOo0wttNf5NP/T7Rrlv1Sp3K8qyiCw==\";\nconst BRIDGE_SIGNATURE_2: \u0026str =\n    \"+Y5UhcFimBzBnJX8BIFZPR2DjUp3DaYVRF81osV/qx8E4gDWk3z1EtUsLX3oITTld0lc12IQGdpuFcCWDAMVAQ==\";\n\nmod stargate;\n\nfn mock_app(owner: \u0026Addr, coins: Vec\u003cCoin\u003e) -\u003e NeutronApp {\n    AppBuilder::new_custom()\n        .with_stargate(MockStargate::default())\n        .build(|router, _, storage| {\n            // initialization moved to App construction\n            router.bank.init_balance(storage, owner, coins).unwrap()\n        })\n}\n\nfn bridge_contract() -\u003e Box\u003cdyn Contract\u003cNeutronMsg, NeutronQuery\u003e\u003e {\n    Box::new(ContractWrapper::new(execute, instantiate, query).with_reply(reply))\n}\n\n#[test]\nfn test_instantiate() {\n    let owner = Addr::unchecked(\"owner\");\n    let mut app = mock_app(\n        \u0026owner,\n        vec![Coin {\n            denom: \"untrn\".to_string(),\n            amount: Uint128::from(1000000u64),\n        }],\n    );\n    let contract_code = app.store_code(bridge_contract());\n\n    // Valid configuration\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Query to check all the values were set\n    let response: Config = app\n        .wrap()\n        .query_wasm_smart(bridge_address, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(response.bridge_chain_id, \"localgaia-1\");\n    assert_eq!(response.bridge_ibc_channel, \"channel-1\");\n    assert_eq!(response.ibc_timeout_seconds, 10);\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: MIN_IBC_TIMEOUT_SECONDS - 1,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MIN_IBC_TIMEOUT_SECONDS - 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: MAX_IBC_TIMEOUT_SECONDS + 1,\n                bridge_ibc_channel: \"channel-1\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MAX_IBC_TIMEOUT_SECONDS + 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string()\n        }\n    );\n\n    let err = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The source chain ID must be specified\".to_string()\n        }\n    );\n}\n\n#[test]\nfn test_add_signer() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add invalid signers\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"signer\".to_string(),\n                public_key_base64: \"invalid_key\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key could not be decoded\".to_string()\n        }\n    );\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a duplicate signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"duplicate-signer\".to_string(),\n                public_key_base64: VALID_SIGNER_1.to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The public key has already been loaded\".to_string()\n        }\n    );\n\n    // Attempt to add a signer without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::AddSigner {\n                name: \"duplicate-signer\".to_string(),\n                public_key_base64: VALID_SIGNER_1.to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Query to check new signer was added\n    let response: QuerySignersResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Signers {})\n        .unwrap();\n\n    assert_eq!(response.signers.len(), 1);\n}\n\n#[test]\nfn test_remove_signer() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Remove an unknown signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"aW52YWxpZC1zaWduZXI=\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key to remove doesn't exist\".to_string()\n        }\n    );\n\n    // Remove an unknown signer\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"invalid_key\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"Key could not be decoded\".to_string()\n        }\n    );\n\n    // Attempt to remove a signer without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::RemoveSigner {\n                public_key_base64: \"aW52YWxpZC1zaWduZXI=\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Remove a known signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::RemoveSigner {\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure signer was removed\n    let response: QuerySignersResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Signers {})\n        .unwrap();\n\n    assert_eq!(response.signers.len(), 0);\n}\n\n#[test]\nfn test_update_config() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Attempt to update config without being the owner\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt blank ibc channel\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: Some(\"\".to_string()),\n                ibc_timeout_seconds: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"The bridge IBC channel must be specified\".to_string()\n        }\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: Some(\"channel-9\".to_string()),\n            ibc_timeout_seconds: None,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt invalid IBC timeout\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: Some(MIN_IBC_TIMEOUT_SECONDS - 1),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MIN_IBC_TIMEOUT_SECONDS - 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                bridge_ibc_channel: None,\n                ibc_timeout_seconds: Some(MAX_IBC_TIMEOUT_SECONDS + 1),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidIBCTimeout {\n            timeout: MAX_IBC_TIMEOUT_SECONDS + 1,\n            min: MIN_IBC_TIMEOUT_SECONDS,\n            max: MAX_IBC_TIMEOUT_SECONDS,\n        }\n    );\n\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::UpdateConfig {\n            bridge_ibc_channel: None,\n            ibc_timeout_seconds: Some(MIN_IBC_TIMEOUT_SECONDS + 1),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check all the new values were set\n    let response: Config = app\n        .wrap()\n        .query_wasm_smart(\u0026bridge_address, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(response.bridge_chain_id, \"localgaia-1\");\n    assert_eq!(response.bridge_ibc_channel, \"channel-9\");\n    assert_eq!(response.ibc_timeout_seconds, MIN_IBC_TIMEOUT_SECONDS + 1);\n}\n\n#[test]\nfn test_link_token() {\n    let owner = Addr::unchecked(\"owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Signatures for TESTTOKEN with 6 decimals\n    let signature_1 =\n        \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\"\n            .to_string();\n    let signature_2 =\n        \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\"\n            .to_string();\n\n    // Duplicate signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone(), signature_1.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::DuplicateSignatures {}\n    );\n\n    // Invalid signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone(), signature_2.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Below threshold signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1.clone()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // No signatures\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"NOT_TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Valid signatures\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![signature_1.clone(), signature_2.clone()],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Attempt to add a duplicate\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::LinkToken {\n                source_chain_id: \"localgaia-1\".to_string(),\n                token: TokenMetadata {\n                    ticker: \"TESTTOKEN\".to_string(),\n                    name: \"TestToken\".to_string(),\n                    image_url: \"https://example.com\".to_string(),\n                    decimals: 6,\n                },\n                signatures: vec![signature_1, signature_2],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenAlreadyExists {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n\n#[test]\nfn test_enable_disable_token() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Signatures for TESTTOKEN with 6 decimals\n    let signature_1 =\n        \"OU5aYIcdVHNVFNcg+MLT9uYVfkNHjTN8Pzg7lHmni5AuCC0ln78lJQnCRi8XxaPaxQYrm3TY+2+LeOU6H9j0DQ==\"\n            .to_string();\n    let signature_2 =\n        \"r3pfcIod2/49HHTOC+QRcVuccg2nOqSZsCNulv+McYFsEOPX7TN3PFscdVfavaGmb3mqdM6vF5italUVrJH3DA==\"\n            .to_string();\n\n    // Valid signatures\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![signature_1.clone(), signature_2.clone()],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Enable a token that wasn't disabled\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::EnableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidConfiguration {\n            reason: \"This token is not disabled\".to_string()\n        }\n    );\n\n    // Disable a token from wrong account\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::DisableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Disable invalid token\n    let err = app\n        .execute_contract(\n            owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::DisableToken {\n                ticker: \"NOT_TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDoesNotExist {\n            ticker: \"NOT_TESTTOKEN\".to_string()\n        }\n    );\n\n    // Disable token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check if it was disabled\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::DisabledTokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(response.tokens.len(), 1);\n\n    // Enable a token from wrong account\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::EnableToken {\n                ticker: \"TESTTOKEN\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::Unauthorized {}\n    );\n\n    // Enable token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::EnableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query to check if it was enabled\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::DisabledTokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(response.tokens.len(), 0);\n}\n\n#[test]\nfn test_bridge_receive() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let mut app = mock_app(\u0026owner, vec![]);\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Receive token not linked yet\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDoesNotExist {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n\n    // Valid signatures\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![\n                SIGNATURE_1.to_string().clone(),\n                SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Ensure the token was actually set up correctly\n    // Query to check all the new values were set\n    let response: QueryTokensResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026bridge_address,\n            \u0026QueryMsg::Tokens {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // We should have two tokens listed in this response as we add a mapping for\n    // CFT-20 \u003c\u003e TokenFactory and TokenFactory \u003c\u003e CFT-20\n    assert_eq!(response.tokens.len(), 2);\n    assert_eq!(response.tokens[0], \"TESTTOKEN\");\n\n    // Receive token with no signatures\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Receive token with invalid signature for the amount\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(10000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Receive zero tokens\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(0u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ZeroAmount {}\n    );\n\n    // Validate that the user has no TESTTOKEN balance\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    assert_eq!(res.len(), 0);\n\n    // Remove a signer to trigger a threshold too low\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::RemoveSigner {\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Bridge transaction with insufficient signatures\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::ThresholdNotMet {}\n    );\n\n    // Add the signer back\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Valid bridge transaction\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::Receive {\n            source_chain_id: \"localgaia-1\".to_string(),\n            transaction_hash: \"TXHASH1\".to_string(),\n            ticker: \"TESTTOKEN\".to_string(),\n            amount: Uint128::from(1000u64),\n            destination_addr: \"user1\".to_string(),\n            signatures: vec![\n                BRIDGE_SIGNATURE_1.to_string().clone(),\n                BRIDGE_SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Assert that the user received the testtoken\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    res.iter().for_each(|coin| {\n        if coin.denom == \"factory/contract0/TESTTOKEN\" {\n            assert_eq!(coin.amount, Uint128::from(1000u64));\n        }\n    });\n\n    // Replay the same transaction\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TransactionAlreadyHandled {\n            transaction_hash: \"TXHASH1\".to_string()\n        }\n    );\n\n    // Try invalid destination address\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidDestinationAddr {}\n    );\n\n    // Disable TESTTOKEN\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Attempt to bridge a disabled token\n    let err = app\n        .execute_contract(\n            not_owner.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Receive {\n                source_chain_id: \"localgaia-1\".to_string(),\n                transaction_hash: \"TXHASH1\".to_string(),\n                ticker: \"TESTTOKEN\".to_string(),\n                amount: Uint128::from(1000u64),\n                destination_addr: \"user1\".to_string(),\n                signatures: vec![\n                    BRIDGE_SIGNATURE_1.to_string().clone(),\n                    BRIDGE_SIGNATURE_2.to_string().clone(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDisabled {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n\n// This test is partial, the rest is tested in a unit test to\n// verify IBC interactions\n#[test]\nfn test_bridge_send() {\n    let owner = Addr::unchecked(\"owner\");\n    let not_owner = Addr::unchecked(\"not_owner\");\n    let user1 = Addr::unchecked(\"user1\");\n    let mut app = mock_app(\n        \u0026user1,\n        vec![\n            Coin {\n                denom: \"untrn\".to_string(),\n                amount: Uint128::from(1000000u64),\n            },\n            Coin {\n                denom: \"uatom\".to_string(),\n                amount: Uint128::from(1000000u64),\n            },\n        ],\n    );\n    let contract_code = app.store_code(bridge_contract());\n\n    let bridge_address = app\n        .instantiate_contract(\n            contract_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                owner: owner.to_string(),\n                ibc_timeout_seconds: 10,\n                bridge_ibc_channel: \"channel-0\".to_string(),\n                bridge_chain_id: \"localgaia-1\".to_string(),\n            },\n            \u0026[],\n            \"Asteroid Bridge\",\n            None,\n        )\n        .unwrap();\n\n    // Add a valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer1\".to_string(),\n            public_key_base64: VALID_SIGNER_1.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Add a second valid signer\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::AddSigner {\n            name: \"signer2\".to_string(),\n            public_key_base64: VALID_SIGNER_2.to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Link token\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::LinkToken {\n            source_chain_id: \"localgaia-1\".to_string(),\n            token: TokenMetadata {\n                ticker: \"TESTTOKEN\".to_string(),\n                name: \"TestToken\".to_string(),\n                image_url: \"https://example.com\".to_string(),\n                decimals: 6,\n            },\n            signatures: vec![\n                SIGNATURE_1.to_string().clone(),\n                SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Valid bridge transaction\n    app.execute_contract(\n        not_owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::Receive {\n            source_chain_id: \"localgaia-1\".to_string(),\n            transaction_hash: \"TXHASH1\".to_string(),\n            ticker: \"TESTTOKEN\".to_string(),\n            amount: Uint128::from(1000u64),\n            destination_addr: \"user1\".to_string(),\n            signatures: vec![\n                BRIDGE_SIGNATURE_1.to_string().clone(),\n                BRIDGE_SIGNATURE_2.to_string().clone(),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Assert that the user received the testtoken\n    let res = app.wrap().query_all_balances(\"user1\").unwrap();\n    res.iter().for_each(|coin| {\n        if coin.denom == \"factory/contract0/TESTTOKEN\" {\n            assert_eq!(coin.amount, Uint128::from(1000u64));\n        }\n    });\n\n    // Check the total supply of the token\n    let res = app\n        .wrap()\n        .query_supply(\"factory/contract0/TESTTOKEN\".to_string())\n        .unwrap();\n    assert_eq!(res.amount, Uint128::from(1000u64));\n\n    // Send incorrect tokens\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                // Coin {\n                //     denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                //     amount: Uint128::from(1u64),\n                // },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                // Coin {\n                //     denom: \"untrn\".to_string(),\n                //     amount: Uint128::from(1u64),\n                // },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"uatom\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::InvalidFunds {}\n    );\n\n    // Disable the token\n    app.execute_contract(\n        owner.clone(),\n        bridge_address.clone(),\n        \u0026ExecuteMsg::DisableToken {\n            ticker: \"TESTTOKEN\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Try bridging disabled token\n    let err = app\n        .execute_contract(\n            user1.clone(),\n            bridge_address.clone(),\n            \u0026ExecuteMsg::Send {\n                destination_addr: \"cosmos1hubaddress\".to_string(),\n            },\n            \u0026[\n                Coin {\n                    denom: \"factory/contract0/TESTTOKEN\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n                Coin {\n                    denom: \"untrn\".to_string(),\n                    amount: Uint128::from(1u64),\n                },\n            ],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.downcast::\u003cContractError\u003e().unwrap(),\n        ContractError::TokenDisabled {\n            ticker: \"TESTTOKEN\".to_string()\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","asteroidprotocol","bridge","contracts","neutron-bridge","tests","stargate.rs"],"content":"use cosmwasm_schema::serde::de::DeserializeOwned;\nuse cosmwasm_std::{\n    coins,\n    testing::{MockApi, MockStorage},\n    Addr, Api, BankMsg, Binary, BlockInfo, CustomMsg, CustomQuery, Empty, Querier, Storage,\n    SubMsgResponse,\n};\nuse cw_multi_test::{\n    App, AppResponse, BankKeeper, BankSudo, CosmosRouter, DistributionKeeper, FailingModule,\n    GovFailingModule, IbcFailingModule, Module, StakeKeeper, Stargate, StargateMsg, StargateQuery,\n    SudoMsg, WasmKeeper,\n};\n\nuse anyhow::{Ok, Result as AnyResult};\nuse osmosis_std::types::osmosis::tokenfactory::v1beta1::{\n    MsgBurn, MsgCreateDenom, MsgCreateDenomResponse, MsgMint, MsgSetBeforeSendHook,\n    MsgSetDenomMetadata, MsgSetDenomMetadataResponse,\n};\n\npub type StargateApp\u003cExecC = Empty, QueryC = Empty\u003e = App\u003c\n    BankKeeper,\n    MockApi,\n    MockStorage,\n    FailingModule\u003cExecC, QueryC, Empty\u003e,\n    WasmKeeper\u003cExecC, QueryC\u003e,\n    StakeKeeper,\n    DistributionKeeper,\n    IbcFailingModule,\n    GovFailingModule,\n    MockStargate,\n\u003e;\n\n#[derive(Default)]\npub struct MockStargate {}\n\nimpl Stargate for MockStargate {}\n\nimpl Module for MockStargate {\n    type ExecT = StargateMsg;\n    type QueryT = StargateQuery;\n    type SudoT = Empty;\n\n    fn execute\u003cExecC, QueryC\u003e(\n        \u0026self,\n        api: \u0026dyn Api,\n        storage: \u0026mut dyn Storage,\n        router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        block: \u0026BlockInfo,\n        sender: Addr,\n        msg: Self::ExecT,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: CustomMsg + DeserializeOwned + 'static,\n        QueryC: CustomQuery + DeserializeOwned + 'static,\n    {\n        let StargateMsg {\n            type_url, value, ..\n        } = msg;\n\n        match type_url.as_str() {\n            MsgCreateDenom::TYPE_URL =\u003e {\n                let tf_msg: MsgCreateDenom = value.try_into()?;\n                let sender_address = tf_msg.sender.to_string();\n                let submsg_response = SubMsgResponse {\n                    events: vec![],\n                    data: Some(\n                        MsgCreateDenomResponse {\n                            new_token_denom: format!(\n                                \"factory/{}/{}\",\n                                sender_address, tf_msg.subdenom\n                            ),\n                        }\n                        .into(),\n                    ),\n                };\n                Ok(submsg_response.into())\n            }\n            MsgMint::TYPE_URL =\u003e {\n                let tf_msg: MsgMint = value.try_into()?;\n                let mint_coins = tf_msg\n                    .amount\n                    .expect(\"Empty amount in tokenfactory MsgMint!\");\n                #[cfg(not(any(feature = \"injective\", feature = \"sei\")))]\n                let to_address = tf_msg.mint_to_address.to_string();\n                #[cfg(any(feature = \"injective\", feature = \"sei\"))]\n                let to_address = sender.to_string();\n                let bank_sudo = BankSudo::Mint {\n                    to_address,\n                    amount: coins(mint_coins.amount.parse()?, mint_coins.denom),\n                };\n                router.sudo(api, storage, block, bank_sudo.into())\n            }\n            MsgBurn::TYPE_URL =\u003e {\n                let tf_msg: MsgBurn = value.try_into()?;\n                let burn_coins = tf_msg\n                    .amount\n                    .expect(\"Empty amount in tokenfactory MsgBurn!\");\n                let burn_msg = BankMsg::Burn {\n                    amount: coins(burn_coins.amount.parse()?, burn_coins.denom),\n                };\n                router.execute(\n                    api,\n                    storage,\n                    block,\n                    Addr::unchecked(sender),\n                    burn_msg.into(),\n                )\n            }\n            MsgSetBeforeSendHook::TYPE_URL =\u003e {\n                let before_hook_msg: MsgSetBeforeSendHook = value.try_into()?;\n                let msg = BankSudo::SetHook {\n                    contract_addr: before_hook_msg.cosmwasm_address,\n                    denom: before_hook_msg.denom,\n                };\n                router.sudo(api, storage, block, SudoMsg::Bank(msg))\n            }\n            MsgSetDenomMetadata::TYPE_URL =\u003e {\n                let _tf_msg: MsgSetDenomMetadata = value.try_into()?;\n                let submsg_response = SubMsgResponse {\n                    events: vec![],\n                    data: Some(MsgSetDenomMetadataResponse {}.into()),\n                };\n                Ok(submsg_response.into())\n            }\n            _ =\u003e Err(anyhow::anyhow!(\n                \"Unexpected exec msg {type_url} from {sender:?}\",\n            )),\n        }\n    }\n    fn query(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        _request: Self::QueryT,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        Ok(Binary::default())\n    }\n    fn sudo\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        _msg: Self::SudoT,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: CustomMsg + DeserializeOwned + 'static,\n        QueryC: CustomQuery + DeserializeOwned + 'static,\n    {\n        unimplemented!(\"Sudo not implemented\")\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>